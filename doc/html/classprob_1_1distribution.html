<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Libprob: prob::distribution&lt; Scalar, T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Libprob
   &#160;<span id="projectnumber">0.1</span>
   </div>
   <div id="projectbrief">Probability Theory Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.2 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classprob_1_1distribution.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classprob_1_1distribution-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">prob::distribution&lt; Scalar, T &gt; Class Template Reference<div class="ingroups"><a class="el" href="group___d_i_s_t.html">Probability Distributions</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A discrete probability distribution backed by a dense <a href="http://eigen.tuxfamily.org/">Eigen</a> matrix.  
 <a href="classprob_1_1distribution.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_distribution_8hpp_source.html">Distribution.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for prob::distribution&lt; Scalar, T &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classprob_1_1distribution__inherit__graph.png" border="0" usemap="#prob_1_1distribution_3_01_scalar_00_01_t_01_4_inherit__map" alt="Inheritance graph"/></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for prob::distribution&lt; Scalar, T &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classprob_1_1distribution__coll__graph.png" border="0" usemap="#prob_1_1distribution_3_01_scalar_00_01_t_01_4_coll__map" alt="Collaboration graph"/></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprob_1_1distribution_1_1type__to__distribution_3_01_u_3_01___t_8_8_8_4_01_4.html">type_to_distribution&lt; U&lt; _T...&gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable type to distribution type conversion.  <a href="structprob_1_1distribution_1_1type__to__distribution_3_01_u_3_01___t_8_8_8_4_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a46b3a3564983ebb669b27be5517f344c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a46b3a3564983ebb669b27be5517f344c"></a>
typedef Scalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprob_1_1distribution.html#a46b3a3564983ebb669b27be5517f344c">scalar</a></td></tr>
<tr class="memdesc:a46b3a3564983ebb669b27be5517f344c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the scalar type. <br/></td></tr>
<tr class="separator:a46b3a3564983ebb669b27be5517f344c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87f265962c64168c63c1e3b222721712"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Matrix&lt; Scalar, <br class="typebreak"/>
core::splitter&lt; T...&gt;<br class="typebreak"/>
::conditional_type::eigen_size, <br class="typebreak"/>
core::splitter&lt; T...&gt;<br class="typebreak"/>
::posterior_type::eigen_size &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprob_1_1distribution.html#a87f265962c64168c63c1e3b222721712">matrix_type</a></td></tr>
<tr class="memdesc:a87f265962c64168c63c1e3b222721712"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eigen base matrix type.  <a href="#a87f265962c64168c63c1e3b222721712"></a><br/></td></tr>
<tr class="separator:a87f265962c64168c63c1e3b222721712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d6230284b3d75ad0e0a629e0bb8dca7"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Matrix&lt; Scalar, <br class="typebreak"/>
1, core::splitter&lt; T...&gt;<br class="typebreak"/>
::posterior_type::eigen_size &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprob_1_1distribution.html#a6d6230284b3d75ad0e0a629e0bb8dca7">posterior_matrix_type</a></td></tr>
<tr class="memdesc:a6d6230284b3d75ad0e0a629e0bb8dca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Posterior distribution matrix base type.  <a href="#a6d6230284b3d75ad0e0a629e0bb8dca7"></a><br/></td></tr>
<tr class="separator:a6d6230284b3d75ad0e0a629e0bb8dca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2103389fda6e20c0b00b44cefd328e83"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Matrix&lt; Scalar, <br class="typebreak"/>
core::splitter&lt; T...&gt;<br class="typebreak"/>
::posterior_type::eigen_size, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprob_1_1distribution.html#a2103389fda6e20c0b00b44cefd328e83">conditional_matrix_type</a></td></tr>
<tr class="separator:a2103389fda6e20c0b00b44cefd328e83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0092b66fbebee633e8016f625797f05f"><td class="memItemLeft" align="right" valign="top">typedef core::splitter&lt; T...&gt;<br class="typebreak"/>
::conditional_type::index_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprob_1_1distribution.html#a0092b66fbebee633e8016f625797f05f">row_type</a></td></tr>
<tr class="memdesc:a0092b66fbebee633e8016f625797f05f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Row extents/indices tuple type.  <a href="#a0092b66fbebee633e8016f625797f05f"></a><br/></td></tr>
<tr class="separator:a0092b66fbebee633e8016f625797f05f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd77ec1aad9829f29e9231068760b365"><td class="memItemLeft" align="right" valign="top">typedef core::splitter&lt; T...&gt;<br class="typebreak"/>
::posterior_type::index_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprob_1_1distribution.html#acd77ec1aad9829f29e9231068760b365">col_type</a></td></tr>
<tr class="memdesc:acd77ec1aad9829f29e9231068760b365"><td class="mdescLeft">&#160;</td><td class="mdescRight">Column extents/indices tuple type.  <a href="#acd77ec1aad9829f29e9231068760b365"></a><br/></td></tr>
<tr class="separator:acd77ec1aad9829f29e9231068760b365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dd34cc3e39b2ed244f0fcc50b458827"><td class="memItemLeft" align="right" valign="top">typedef core::splitter&lt; T...&gt;<br class="typebreak"/>
::<a class="el" href="classprob_1_1distribution.html#a1dd34cc3e39b2ed244f0fcc50b458827">conditional_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprob_1_1distribution.html#a1dd34cc3e39b2ed244f0fcc50b458827">conditional_type</a></td></tr>
<tr class="memdesc:a1dd34cc3e39b2ed244f0fcc50b458827"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditional variables type type.  <a href="#a1dd34cc3e39b2ed244f0fcc50b458827"></a><br/></td></tr>
<tr class="separator:a1dd34cc3e39b2ed244f0fcc50b458827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d4c2f3d3767af87f73e450bb3b7b1b9"><td class="memItemLeft" align="right" valign="top">typedef core::splitter&lt; T...&gt;<br class="typebreak"/>
::<a class="el" href="classprob_1_1distribution.html#a7d4c2f3d3767af87f73e450bb3b7b1b9">posterior_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprob_1_1distribution.html#a7d4c2f3d3767af87f73e450bb3b7b1b9">posterior_type</a></td></tr>
<tr class="memdesc:a7d4c2f3d3767af87f73e450bb3b7b1b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Posterior variables type.  <a href="#a7d4c2f3d3767af87f73e450bb3b7b1b9"></a><br/></td></tr>
<tr class="separator:a7d4c2f3d3767af87f73e450bb3b7b1b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75e2d3d5bc94f27c5dd651d90f6bde06"><td class="memItemLeft" align="right" valign="top">typedef core::splitter&lt; T...&gt;<br class="typebreak"/>
::<a class="el" href="classprob_1_1distribution.html#a75e2d3d5bc94f27c5dd651d90f6bde06">expanded_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprob_1_1distribution.html#a75e2d3d5bc94f27c5dd651d90f6bde06">expanded_type</a></td></tr>
<tr class="memdesc:a75e2d3d5bc94f27c5dd651d90f6bde06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random variables type.  <a href="#a75e2d3d5bc94f27c5dd651d90f6bde06"></a><br/></td></tr>
<tr class="separator:a75e2d3d5bc94f27c5dd651d90f6bde06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c6e563439d1a53548f824b169108e01"><td class="memItemLeft" align="right" valign="top">typedef type_to_distribution<br class="typebreak"/>
&lt; <a class="el" href="classprob_1_1distribution.html#a7d4c2f3d3767af87f73e450bb3b7b1b9">posterior_type</a> &gt;<br class="typebreak"/>
::distribution_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprob_1_1distribution.html#a7c6e563439d1a53548f824b169108e01">posterior_distribution_type</a></td></tr>
<tr class="memdesc:a7c6e563439d1a53548f824b169108e01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Posterior distribution type.  <a href="#a7c6e563439d1a53548f824b169108e01"></a><br/></td></tr>
<tr class="separator:a7c6e563439d1a53548f824b169108e01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cceb9b760a52f094fec2f70151b5b0a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0cceb9b760a52f094fec2f70151b5b0a"></a>
typedef type_to_distribution<br class="typebreak"/>
&lt; <a class="el" href="classprob_1_1distribution.html#a1dd34cc3e39b2ed244f0fcc50b458827">conditional_type</a> &gt;<br class="typebreak"/>
::distribution_type&#160;</td><td class="memItemRight" valign="bottom"><b>conditional_distribution_type</b></td></tr>
<tr class="separator:a0cceb9b760a52f094fec2f70151b5b0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a072f64ca65f96299616a67133264a3b4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprob_1_1distribution.html#a072f64ca65f96299616a67133264a3b4">distribution</a> ()</td></tr>
<tr class="memdesc:a072f64ca65f96299616a67133264a3b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#a072f64ca65f96299616a67133264a3b4"></a><br/></td></tr>
<tr class="separator:a072f64ca65f96299616a67133264a3b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcd9f27168ec84c1a5282eb08a4a164e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abcd9f27168ec84c1a5282eb08a4a164e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprob_1_1distribution.html#abcd9f27168ec84c1a5282eb08a4a164e">distribution</a> (const <a class="el" href="classprob_1_1distribution.html">distribution</a>&lt; Scalar, T...&gt; &amp;other)</td></tr>
<tr class="memdesc:abcd9f27168ec84c1a5282eb08a4a164e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. <br/></td></tr>
<tr class="separator:abcd9f27168ec84c1a5282eb08a4a164e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a693b1bba233c5f450375d373e91583f0"><td class="memTemplParams" colspan="2">template&lt;typename S &gt; </td></tr>
<tr class="memitem:a693b1bba233c5f450375d373e91583f0"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classprob_1_1distribution.html#a693b1bba233c5f450375d373e91583f0">distribution</a> (const S &amp;other, const <a class="el" href="classprob_1_1distribution.html#a0092b66fbebee633e8016f625797f05f">row_type</a> &amp;<a class="el" href="classprob_1_1distribution.html#a65688371b7bf210e2a23c31eff38fb5b">row_extents</a>, const <a class="el" href="classprob_1_1distribution.html#acd77ec1aad9829f29e9231068760b365">col_type</a> &amp;<a class="el" href="classprob_1_1distribution.html#a2a4c3140b3bf2ae48923ede6343a483c">col_extents</a>)</td></tr>
<tr class="memdesc:a693b1bba233c5f450375d373e91583f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quasi copy constructor.  <a href="#a693b1bba233c5f450375d373e91583f0"></a><br/></td></tr>
<tr class="separator:a693b1bba233c5f450375d373e91583f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fd283aa710f25f2ebd298ee0e23b39f"><td class="memTemplParams" colspan="2">template&lt;typename... _T&gt; </td></tr>
<tr class="memitem:a0fd283aa710f25f2ebd298ee0e23b39f"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classprob_1_1distribution.html#a0fd283aa710f25f2ebd298ee0e23b39f">distribution</a> (_T...t)</td></tr>
<tr class="memdesc:a0fd283aa710f25f2ebd298ee0e23b39f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for distributions with dynamically sized random variables.  <a href="#a0fd283aa710f25f2ebd298ee0e23b39f"></a><br/></td></tr>
<tr class="separator:a0fd283aa710f25f2ebd298ee0e23b39f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93804ac770167a1405ccb5e38c025e8d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a93804ac770167a1405ccb5e38c025e8d"></a>
<a class="el" href="classprob_1_1distribution.html">distribution</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classprob_1_1distribution.html">distribution</a> &amp;other)</td></tr>
<tr class="separator:a93804ac770167a1405ccb5e38c025e8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04935b298e4d7c5ccb0b0e39ee7a9600"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a04935b298e4d7c5ccb0b0e39ee7a9600"></a>
<a class="el" href="classprob_1_1distribution.html#a0092b66fbebee633e8016f625797f05f">row_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprob_1_1distribution.html#a04935b298e4d7c5ccb0b0e39ee7a9600">conditional_extents</a> () const </td></tr>
<tr class="memdesc:a04935b298e4d7c5ccb0b0e39ee7a9600"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extents of the conditional variables as a tuple. <br/></td></tr>
<tr class="separator:a04935b298e4d7c5ccb0b0e39ee7a9600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a3cd6ec1534f9a016b32a55dd642c15"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9a3cd6ec1534f9a016b32a55dd642c15"></a>
<a class="el" href="classprob_1_1distribution.html#acd77ec1aad9829f29e9231068760b365">col_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprob_1_1distribution.html#a9a3cd6ec1534f9a016b32a55dd642c15">posterior_extents</a> () const </td></tr>
<tr class="memdesc:a9a3cd6ec1534f9a016b32a55dd642c15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extents of the posterior variables as a tuple. <br/></td></tr>
<tr class="separator:a9a3cd6ec1534f9a016b32a55dd642c15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65688371b7bf210e2a23c31eff38fb5b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a65688371b7bf210e2a23c31eff38fb5b"></a>
<a class="el" href="classprob_1_1distribution.html#a0092b66fbebee633e8016f625797f05f">row_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprob_1_1distribution.html#a65688371b7bf210e2a23c31eff38fb5b">row_extents</a> () const </td></tr>
<tr class="memdesc:a65688371b7bf210e2a23c31eff38fb5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for conditional_extents. <br/></td></tr>
<tr class="separator:a65688371b7bf210e2a23c31eff38fb5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a4c3140b3bf2ae48923ede6343a483c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2a4c3140b3bf2ae48923ede6343a483c"></a>
<a class="el" href="classprob_1_1distribution.html#acd77ec1aad9829f29e9231068760b365">col_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprob_1_1distribution.html#a2a4c3140b3bf2ae48923ede6343a483c">col_extents</a> () const </td></tr>
<tr class="memdesc:a2a4c3140b3bf2ae48923ede6343a483c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for posterior_extents. <br/></td></tr>
<tr class="separator:a2a4c3140b3bf2ae48923ede6343a483c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaea87e18a2fca2c7f1fdcceee58cbf0"><td class="memTemplParams" colspan="2"><a class="anchor" id="acaea87e18a2fca2c7f1fdcceee58cbf0"></a>
template&lt;size_t i&gt; </td></tr>
<tr class="memitem:acaea87e18a2fca2c7f1fdcceee58cbf0"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classprob_1_1distribution.html#acaea87e18a2fca2c7f1fdcceee58cbf0">conditional_extent</a> ()</td></tr>
<tr class="memdesc:acaea87e18a2fca2c7f1fdcceee58cbf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extent of the i-th conditional variable. <br/></td></tr>
<tr class="separator:acaea87e18a2fca2c7f1fdcceee58cbf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a932ba7996c416b21f140299d5402b4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7a932ba7996c416b21f140299d5402b4"></a>
template&lt;size_t i&gt; </td></tr>
<tr class="memitem:a7a932ba7996c416b21f140299d5402b4"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classprob_1_1distribution.html#a7a932ba7996c416b21f140299d5402b4">posterior_extent</a> ()</td></tr>
<tr class="memdesc:a7a932ba7996c416b21f140299d5402b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extent of the i-th posterior variable. <br/></td></tr>
<tr class="separator:a7a932ba7996c416b21f140299d5402b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ca124d25f1451361a4c882be76c1004"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2ca124d25f1451361a4c882be76c1004"></a>
template&lt;size_t i&gt; </td></tr>
<tr class="memitem:a2ca124d25f1451361a4c882be76c1004"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classprob_1_1distribution.html#a2ca124d25f1451361a4c882be76c1004">row_extent</a> ()</td></tr>
<tr class="memdesc:a2ca124d25f1451361a4c882be76c1004"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for conditional_extent. <br/></td></tr>
<tr class="separator:a2ca124d25f1451361a4c882be76c1004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0993a2e19035b6d4cec3e274347e079"><td class="memTemplParams" colspan="2"><a class="anchor" id="af0993a2e19035b6d4cec3e274347e079"></a>
template&lt;size_t i&gt; </td></tr>
<tr class="memitem:af0993a2e19035b6d4cec3e274347e079"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classprob_1_1distribution.html#af0993a2e19035b6d4cec3e274347e079">col_extent</a> ()</td></tr>
<tr class="memdesc:af0993a2e19035b6d4cec3e274347e079"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for posterior_extent. <br/></td></tr>
<tr class="separator:af0993a2e19035b6d4cec3e274347e079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a894a0c5da26697111aab42be99deeba1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprob_1_1distribution.html#a894a0c5da26697111aab42be99deeba1">reshape_dimensions</a> (const <a class="el" href="classprob_1_1distribution.html#a0092b66fbebee633e8016f625797f05f">row_type</a> &amp;new_row_extents, const <a class="el" href="classprob_1_1distribution.html#acd77ec1aad9829f29e9231068760b365">col_type</a> &amp;new_col_extents)</td></tr>
<tr class="memdesc:a894a0c5da26697111aab42be99deeba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reshape the extents of the distribution.  <a href="#a894a0c5da26697111aab42be99deeba1"></a><br/></td></tr>
<tr class="separator:a894a0c5da26697111aab42be99deeba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c1a6743807a2a7980fbdeb690bc8236"><td class="memTemplParams" colspan="2">template&lt;typename... _T&gt; </td></tr>
<tr class="memitem:a4c1a6743807a2a7980fbdeb690bc8236"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classprob_1_1distribution.html#a4c1a6743807a2a7980fbdeb690bc8236">reshape</a> (_T &amp;&amp;...t)</td></tr>
<tr class="memdesc:a4c1a6743807a2a7980fbdeb690bc8236"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reshape the extents of the distribution.  <a href="#a4c1a6743807a2a7980fbdeb690bc8236"></a><br/></td></tr>
<tr class="separator:a4c1a6743807a2a7980fbdeb690bc8236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b9469252e82c6af3845bb94b5d3695d"><td class="memTemplParams" colspan="2">template&lt;typename... _T&gt; </td></tr>
<tr class="memitem:a0b9469252e82c6af3845bb94b5d3695d"><td class="memTemplItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classprob_1_1distribution.html#a0b9469252e82c6af3845bb94b5d3695d">prob_read_or_zero</a> (_T &amp;&amp;...t)</td></tr>
<tr class="memdesc:a0b9469252e82c6af3845bb94b5d3695d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a probability value.  <a href="#a0b9469252e82c6af3845bb94b5d3695d"></a><br/></td></tr>
<tr class="separator:a0b9469252e82c6af3845bb94b5d3695d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9a29235904c048b6c8363fb0ccbc65e"><td class="memItemLeft" align="right" valign="top">Scalar &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprob_1_1distribution.html#ab9a29235904c048b6c8363fb0ccbc65e">prob_ref_via_tuple</a> (const <a class="el" href="classprob_1_1distribution.html#a0092b66fbebee633e8016f625797f05f">row_type</a> &amp;row_index, const <a class="el" href="classprob_1_1distribution.html#acd77ec1aad9829f29e9231068760b365">col_type</a> &amp;col_index)</td></tr>
<tr class="memdesc:ab9a29235904c048b6c8363fb0ccbc65e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a probability reference using two index tuples.  <a href="#ab9a29235904c048b6c8363fb0ccbc65e"></a><br/></td></tr>
<tr class="separator:ab9a29235904c048b6c8363fb0ccbc65e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42f3b635a1252ee58dd34e9174c19787"><td class="memItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprob_1_1distribution.html#a42f3b635a1252ee58dd34e9174c19787">prob_via_tuple</a> (const <a class="el" href="classprob_1_1distribution.html#a0092b66fbebee633e8016f625797f05f">row_type</a> &amp;row_index, const <a class="el" href="classprob_1_1distribution.html#acd77ec1aad9829f29e9231068760b365">col_type</a> &amp;col_index)</td></tr>
<tr class="memdesc:a42f3b635a1252ee58dd34e9174c19787"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a probability using two index tuples.  <a href="#a42f3b635a1252ee58dd34e9174c19787"></a><br/></td></tr>
<tr class="separator:a42f3b635a1252ee58dd34e9174c19787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bc0e71ef75c54c780dd6d84f277a7c0"><td class="memTemplParams" colspan="2">template&lt;typename... _T&gt; </td></tr>
<tr class="memitem:a9bc0e71ef75c54c780dd6d84f277a7c0"><td class="memTemplItemLeft" align="right" valign="top">Scalar &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classprob_1_1distribution.html#a9bc0e71ef75c54c780dd6d84f277a7c0">prob_ref</a> (_T...t)</td></tr>
<tr class="memdesc:a9bc0e71ef75c54c780dd6d84f277a7c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a probability reference.  <a href="#a9bc0e71ef75c54c780dd6d84f277a7c0"></a><br/></td></tr>
<tr class="separator:a9bc0e71ef75c54c780dd6d84f277a7c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fe42bfd07878e6555dc124aafdb7968"><td class="memTemplParams" colspan="2">template&lt;typename... _T&gt; </td></tr>
<tr class="memitem:a6fe42bfd07878e6555dc124aafdb7968"><td class="memTemplItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classprob_1_1distribution.html#a6fe42bfd07878e6555dc124aafdb7968">operator()</a> (_T...t) const </td></tr>
<tr class="memdesc:a6fe42bfd07878e6555dc124aafdb7968"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a probability value.  <a href="#a6fe42bfd07878e6555dc124aafdb7968"></a><br/></td></tr>
<tr class="separator:a6fe42bfd07878e6555dc124aafdb7968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a411f0fa70a11adc18fcf86ec323cdc67"><td class="memTemplParams" colspan="2"><a class="anchor" id="a411f0fa70a11adc18fcf86ec323cdc67"></a>
template&lt;typename... _T&gt; </td></tr>
<tr class="memitem:a411f0fa70a11adc18fcf86ec323cdc67"><td class="memTemplItemLeft" align="right" valign="top">Scalar &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classprob_1_1distribution.html#a411f0fa70a11adc18fcf86ec323cdc67">operator()</a> (_T &amp;&amp;...t)</td></tr>
<tr class="memdesc:a411f0fa70a11adc18fcf86ec323cdc67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for prob_ref. <br/></td></tr>
<tr class="separator:a411f0fa70a11adc18fcf86ec323cdc67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2fe90cdf900d44bdbcf4a19a54a6274"><td class="memTemplParams" colspan="2">template&lt;typename... _T&gt; </td></tr>
<tr class="memitem:ab2fe90cdf900d44bdbcf4a19a54a6274"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classprob_1_1distribution.html#a7c6e563439d1a53548f824b169108e01">posterior_distribution_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classprob_1_1distribution.html#ab2fe90cdf900d44bdbcf4a19a54a6274">posterior_distribution</a> (_T &amp;&amp;...t) const </td></tr>
<tr class="memdesc:ab2fe90cdf900d44bdbcf4a19a54a6274"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a conditioned posterior distribution.  <a href="#ab2fe90cdf900d44bdbcf4a19a54a6274"></a><br/></td></tr>
<tr class="separator:ab2fe90cdf900d44bdbcf4a19a54a6274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4333addc3a829eebfe8648b01e17eca0"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a4333addc3a829eebfe8648b01e17eca0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classprob_1_1distribution.html#a4333addc3a829eebfe8648b01e17eca0">each_index</a> (F f) const </td></tr>
<tr class="memdesc:a4333addc3a829eebfe8648b01e17eca0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over all variable indices.  <a href="#a4333addc3a829eebfe8648b01e17eca0"></a><br/></td></tr>
<tr class="separator:a4333addc3a829eebfe8648b01e17eca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf8d208914da012381733fcbb04bdfde"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:abf8d208914da012381733fcbb04bdfde"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classprob_1_1distribution.html#abf8d208914da012381733fcbb04bdfde">each_index_reverse</a> (F f) const </td></tr>
<tr class="memdesc:abf8d208914da012381733fcbb04bdfde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over all variable indices with reversed loops.  <a href="#abf8d208914da012381733fcbb04bdfde"></a><br/></td></tr>
<tr class="separator:abf8d208914da012381733fcbb04bdfde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32d8502fd7b43d5261f66423c126aea4"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a32d8502fd7b43d5261f66423c126aea4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classprob_1_1distribution.html#a32d8502fd7b43d5261f66423c126aea4">each_conditional_index</a> (F f) const </td></tr>
<tr class="memdesc:a32d8502fd7b43d5261f66423c126aea4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over all conditional variable indices.  <a href="#a32d8502fd7b43d5261f66423c126aea4"></a><br/></td></tr>
<tr class="separator:a32d8502fd7b43d5261f66423c126aea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f94dd12247febf409b1406905b214fc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0f94dd12247febf409b1406905b214fc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprob_1_1distribution.html#a0f94dd12247febf409b1406905b214fc">normalize</a> ()</td></tr>
<tr class="memdesc:a0f94dd12247febf409b1406905b214fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize the distribution. <br/></td></tr>
<tr class="separator:a0f94dd12247febf409b1406905b214fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae968bc8951b132e429ea5e57a7be5b6c"><td class="memItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprob_1_1distribution.html#ae968bc8951b132e429ea5e57a7be5b6c">sum</a> ()</td></tr>
<tr class="memdesc:ae968bc8951b132e429ea5e57a7be5b6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum of all probability values in the distribution.  <a href="#ae968bc8951b132e429ea5e57a7be5b6c"></a><br/></td></tr>
<tr class="separator:ae968bc8951b132e429ea5e57a7be5b6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd233e6cccabe9f3f8169e31a0d64d3"><td class="memItemLeft" align="right" valign="top">conditional_distribution_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprob_1_1distribution.html#a7cd233e6cccabe9f3f8169e31a0d64d3">sum_by_conditional</a> ()</td></tr>
<tr class="memdesc:a7cd233e6cccabe9f3f8169e31a0d64d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum of all probability values grouped by conditionals.  <a href="#a7cd233e6cccabe9f3f8169e31a0d64d3"></a><br/></td></tr>
<tr class="separator:a7cd233e6cccabe9f3f8169e31a0d64d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9a9904a0d545203c94a77efd0cf08e7"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:af9a9904a0d545203c94a77efd0cf08e7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classprob_1_1distribution.html">distribution</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classprob_1_1distribution.html#af9a9904a0d545203c94a77efd0cf08e7">map</a> (F &amp;&amp;f)</td></tr>
<tr class="memdesc:af9a9904a0d545203c94a77efd0cf08e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a function to each probability value.  <a href="#af9a9904a0d545203c94a77efd0cf08e7"></a><br/></td></tr>
<tr class="separator:af9a9904a0d545203c94a77efd0cf08e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe414bb30baa0141c643ba688835a1cc"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:abe414bb30baa0141c643ba688835a1cc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classprob_1_1distribution.html">distribution</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classprob_1_1distribution.html#abe414bb30baa0141c643ba688835a1cc">map_copy</a> (F &amp;&amp;f) const </td></tr>
<tr class="memdesc:abe414bb30baa0141c643ba688835a1cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a function to a copy of each probability value.  <a href="#abe414bb30baa0141c643ba688835a1cc"></a><br/></td></tr>
<tr class="separator:abe414bb30baa0141c643ba688835a1cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74565d39808a14314ae10cc69efa0dad"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a74565d39808a14314ae10cc69efa0dad"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classprob_1_1distribution.html">distribution</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classprob_1_1distribution.html#a74565d39808a14314ae10cc69efa0dad">map_by_conditional</a> (F &amp;&amp;f)</td></tr>
<tr class="memdesc:a74565d39808a14314ae10cc69efa0dad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a function to each posterior distribution.  <a href="#a74565d39808a14314ae10cc69efa0dad"></a><br/></td></tr>
<tr class="separator:a74565d39808a14314ae10cc69efa0dad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8648fb1ae7da31fa2553e918f07e448b"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a8648fb1ae7da31fa2553e918f07e448b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classprob_1_1distribution.html">distribution</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classprob_1_1distribution.html#a8648fb1ae7da31fa2553e918f07e448b">map_copy_by_conditional</a> (F &amp;&amp;f) const </td></tr>
<tr class="memdesc:a8648fb1ae7da31fa2553e918f07e448b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a function to a copy of each posterior distribution.  <a href="#a8648fb1ae7da31fa2553e918f07e448b"></a><br/></td></tr>
<tr class="separator:a8648fb1ae7da31fa2553e918f07e448b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ccca8825aa6682cce1b03f55ee0837f"><td class="memTemplParams" colspan="2">template&lt;int... GroupIndices&gt; </td></tr>
<tr class="memitem:a1ccca8825aa6682cce1b03f55ee0837f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classprob_1_1distribution.html#a1ccca8825aa6682cce1b03f55ee0837f">grouped_map_sum</a> (std::function&lt; Scalar(Scalar)&gt; f) const -&gt; typename type_to_distribution&lt; typename core::indexed_type_selector&lt; <a class="el" href="classprob_1_1distribution.html#a75e2d3d5bc94f27c5dd651d90f6bde06">expanded_type</a>, core::splitter&lt; T...&gt;::posteriors(), core::splitter&lt; T...&gt;::conditionals(),-1, GroupIndices...&gt;::result_type &gt;::distribution_type</td></tr>
<tr class="memdesc:a1ccca8825aa6682cce1b03f55ee0837f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generalized marginalization method.  <a href="#a1ccca8825aa6682cce1b03f55ee0837f"></a><br/></td></tr>
<tr class="separator:a1ccca8825aa6682cce1b03f55ee0837f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c5fdfa2b677952c43acbf440ad84569"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4c5fdfa2b677952c43acbf440ad84569"></a>
template&lt;int... GroupIndices&gt; </td></tr>
<tr class="memitem:a4c5fdfa2b677952c43acbf440ad84569"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classprob_1_1distribution.html#a4c5fdfa2b677952c43acbf440ad84569">grouped_sum</a> () const -&gt; typename type_to_distribution&lt; typename core::indexed_type_selector&lt; <a class="el" href="classprob_1_1distribution.html#a75e2d3d5bc94f27c5dd651d90f6bde06">expanded_type</a>, core::splitter&lt; T...&gt;::posteriors(), core::splitter&lt; T...&gt;::conditionals(),-1, GroupIndices...&gt;::result_type &gt;::distribution_type</td></tr>
<tr class="memdesc:a4c5fdfa2b677952c43acbf440ad84569"><td class="mdescLeft">&#160;</td><td class="mdescRight">grouped_map_sum with f being the identity <br/></td></tr>
<tr class="separator:a4c5fdfa2b677952c43acbf440ad84569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9371ea2ae09198694ec0f72fa5f598f2"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9371ea2ae09198694ec0f72fa5f598f2"></a>
template&lt;int... GroupIndices&gt; </td></tr>
<tr class="memitem:a9371ea2ae09198694ec0f72fa5f598f2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classprob_1_1distribution.html#a9371ea2ae09198694ec0f72fa5f598f2">marginalize</a> () const -&gt; typename type_to_distribution&lt; typename core::indexed_type_selector&lt; <a class="el" href="classprob_1_1distribution.html#a75e2d3d5bc94f27c5dd651d90f6bde06">expanded_type</a>, core::splitter&lt; T...&gt;::posteriors(), core::splitter&lt; T...&gt;::conditionals(),-1, GroupIndices...&gt;::result_type &gt;::distribution_type</td></tr>
<tr class="memdesc:a9371ea2ae09198694ec0f72fa5f598f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for grouped_sum. <br/></td></tr>
<tr class="separator:a9371ea2ae09198694ec0f72fa5f598f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79c4940c8871bb9a2f91a863286e09de"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a79c4940c8871bb9a2f91a863286e09de"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprob_1_1distribution.html#a79c4940c8871bb9a2f91a863286e09de">histogram</a> (unsigned width, unsigned height)</td></tr>
<tr class="memdesc:a79c4940c8871bb9a2f91a863286e09de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a histogram as ASCII art in the given dimensions. <br/></td></tr>
<tr class="separator:a79c4940c8871bb9a2f91a863286e09de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e760f95864a459e156d0dbb24711584"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3e760f95864a459e156d0dbb24711584"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprob_1_1distribution.html#a3e760f95864a459e156d0dbb24711584">summary</a> ()</td></tr>
<tr class="memdesc:a3e760f95864a459e156d0dbb24711584"><td class="mdescLeft">&#160;</td><td class="mdescRight">A summary of the distribution for logging pursposes. <br/></td></tr>
<tr class="separator:a3e760f95864a459e156d0dbb24711584"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ad9405bb071b23af1b56924eb55d2122b"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprob_1_1distribution.html#ad9405bb071b23af1b56924eb55d2122b">conditional_distribution</a> ()</td></tr>
<tr class="memdesc:ad9405bb071b23af1b56924eb55d2122b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the distribution a conditional distribution?  <a href="#ad9405bb071b23af1b56924eb55d2122b"></a><br/></td></tr>
<tr class="separator:ad9405bb071b23af1b56924eb55d2122b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae779dbb2a35d94eb8424adb109fa72b9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classprob_1_1distribution.html">distribution</a>&lt; Scalar, T...&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classprob_1_1distribution.html#ae779dbb2a35d94eb8424adb109fa72b9">load</a> (std::istream &amp;in)</td></tr>
<tr class="memdesc:ae779dbb2a35d94eb8424adb109fa72b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a distribution.  <a href="#ae779dbb2a35d94eb8424adb109fa72b9"></a><br/></td></tr>
<tr class="separator:ae779dbb2a35d94eb8424adb109fa72b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a859f005f92d10504d95fdb3c187768b7"><td class="memTemplParams" colspan="2"><a class="anchor" id="a859f005f92d10504d95fdb3c187768b7"></a>
template&lt;bool &gt; </td></tr>
<tr class="memitem:a859f005f92d10504d95fdb3c187768b7"><td class="memTemplItemLeft" align="right" valign="top">struct&#160;</td><td class="memTemplItemRight" valign="bottom"><b>core::conditional_case</b></td></tr>
<tr class="separator:a859f005f92d10504d95fdb3c187768b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Scalar, typename... T&gt;<br/>
class prob::distribution&lt; Scalar, T &gt;</h3>

<p>A discrete probability distribution backed by a dense <a href="http://eigen.tuxfamily.org/">Eigen</a> matrix. </p>
<p>For the purpose of the documentation we assume </p>
<div class="fragment"><div class="line">T... = X..., given, Y... </div>
</div><!-- fragment --><p> (for a conditional distribution) or </p>
<div class="fragment"><div class="line">T... = X...  </div>
</div><!-- fragment --><p> for a non conditional distribution, where all X and Y are random variable types (see <a class="el" href="group___r_v_a_r.html">Random Variables</a>).</p>
<p>The distribution is here denoted by \( p(X... | Y...) \) and its probabilities by \( p(x... | y...) \). The posterior distributions now are \( p(X... | y...) \) also denoted by \( p(\cdot | y...) \).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>The scalar type of the probabilities. All Scalars that work for Eigen matrices are supported, some functions however assume floating point Scalars or specifically double or to/from double convertible. Scalars. </td></tr>
    <tr><td class="paramname">T...</td><td>The type list of the random variable types. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_distribution_8hpp_source.html#l00291">291</a> of file <a class="el" href="_distribution_8hpp_source.html">Distribution.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="acd77ec1aad9829f29e9231068760b365"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar, typename... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef core::splitter&lt;T...&gt;::posterior_type::index_type <a class="el" href="classprob_1_1distribution.html">prob::distribution</a>&lt; Scalar, T &gt;::<a class="el" href="classprob_1_1distribution.html#acd77ec1aad9829f29e9231068760b365">col_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Column extents/indices tuple type. </p>
<p>The tuple type (std::tuple) of the column extents (when denoting the size of the posterior variables) or columns indices when denoting a specific event (of the posterior variables). </p>

<p>Definition at line <a class="el" href="_distribution_8hpp_source.html#l00337">337</a> of file <a class="el" href="_distribution_8hpp_source.html">Distribution.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2103389fda6e20c0b00b44cefd328e83"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar, typename... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Matrix&lt;Scalar, core::splitter&lt;T...&gt;::posterior_type::eigen_size, 1&gt; <a class="el" href="classprob_1_1distribution.html">prob::distribution</a>&lt; Scalar, T &gt;::<a class="el" href="classprob_1_1distribution.html#a2103389fda6e20c0b00b44cefd328e83">conditional_matrix_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The base type of the conditional matrix. This type does not represent a concept from probability theory and is mainly used internally. </p>

<p>Definition at line <a class="el" href="_distribution_8hpp_source.html#l00319">319</a> of file <a class="el" href="_distribution_8hpp_source.html">Distribution.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1dd34cc3e39b2ed244f0fcc50b458827"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar, typename... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef core::splitter&lt;T...&gt;::<a class="el" href="classprob_1_1distribution.html#a1dd34cc3e39b2ed244f0fcc50b458827">conditional_type</a> <a class="el" href="classprob_1_1distribution.html">prob::distribution</a>&lt; Scalar, T &gt;::<a class="el" href="classprob_1_1distribution.html#a1dd34cc3e39b2ed244f0fcc50b458827">conditional_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Conditional variables type type. </p>
<p>The core::vars type of the conditional variables. Gives access to the splitted conditionals. </p>

<p>Definition at line <a class="el" href="_distribution_8hpp_source.html#l00346">346</a> of file <a class="el" href="_distribution_8hpp_source.html">Distribution.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a75e2d3d5bc94f27c5dd651d90f6bde06"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar, typename... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef core::splitter&lt;T...&gt;::<a class="el" href="classprob_1_1distribution.html#a75e2d3d5bc94f27c5dd651d90f6bde06">expanded_type</a> <a class="el" href="classprob_1_1distribution.html">prob::distribution</a>&lt; Scalar, T &gt;::<a class="el" href="classprob_1_1distribution.html#a75e2d3d5bc94f27c5dd651d90f6bde06">expanded_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Random variables type. </p>
<p>The core::vars type of all random variables. Gives access to the expanded variables specificly all <a class="el" href="structprob_1_1__given.html">_given</a> types are expanded. </p>

<p>Definition at line <a class="el" href="_distribution_8hpp_source.html#l00362">362</a> of file <a class="el" href="_distribution_8hpp_source.html">Distribution.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a87f265962c64168c63c1e3b222721712"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar, typename... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Matrix&lt;Scalar, core::splitter&lt;T...&gt;::conditional_type::eigen_size, core::splitter&lt;T...&gt;::posterior_type::eigen_size&gt; <a class="el" href="classprob_1_1distribution.html">prob::distribution</a>&lt; Scalar, T &gt;::<a class="el" href="classprob_1_1distribution.html#a87f265962c64168c63c1e3b222721712">matrix_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Eigen base matrix type. </p>
<p>The base type of the class, a dynamically sized Eigen::Matrix (matrix or vector). </p>

<p>Definition at line <a class="el" href="_distribution_8hpp_source.html#l00305">305</a> of file <a class="el" href="_distribution_8hpp_source.html">Distribution.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7c6e563439d1a53548f824b169108e01"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar, typename... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef type_to_distribution&lt;<a class="el" href="classprob_1_1distribution.html#a7d4c2f3d3767af87f73e450bb3b7b1b9">posterior_type</a>&gt;::distribution_type <a class="el" href="classprob_1_1distribution.html">prob::distribution</a>&lt; Scalar, T &gt;::<a class="el" href="classprob_1_1distribution.html#a7c6e563439d1a53548f824b169108e01">posterior_distribution_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Posterior distribution type. </p>
<p>The type of the posterior distributions i.e \( p(\cdot | y...) \). </p>

<p>Definition at line <a class="el" href="_distribution_8hpp_source.html#l00387">387</a> of file <a class="el" href="_distribution_8hpp_source.html">Distribution.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6d6230284b3d75ad0e0a629e0bb8dca7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar, typename... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Matrix&lt;Scalar, 1, core::splitter&lt;T...&gt;::posterior_type::eigen_size&gt; <a class="el" href="classprob_1_1distribution.html">prob::distribution</a>&lt; Scalar, T &gt;::<a class="el" href="classprob_1_1distribution.html#a6d6230284b3d75ad0e0a629e0bb8dca7">posterior_matrix_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Posterior distribution matrix base type. </p>
<p>The base type of the posterior distributions i.e \( p(\cdot | y...) \). </p>

<p>Definition at line <a class="el" href="_distribution_8hpp_source.html#l00312">312</a> of file <a class="el" href="_distribution_8hpp_source.html">Distribution.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7d4c2f3d3767af87f73e450bb3b7b1b9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar, typename... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef core::splitter&lt;T...&gt;::<a class="el" href="classprob_1_1distribution.html#a7d4c2f3d3767af87f73e450bb3b7b1b9">posterior_type</a> <a class="el" href="classprob_1_1distribution.html">prob::distribution</a>&lt; Scalar, T &gt;::<a class="el" href="classprob_1_1distribution.html#a7d4c2f3d3767af87f73e450bb3b7b1b9">posterior_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Posterior variables type. </p>
<p>The core::vars type of the posterior variables. Gives access to the splitted posteriors. </p>

<p>Definition at line <a class="el" href="_distribution_8hpp_source.html#l00354">354</a> of file <a class="el" href="_distribution_8hpp_source.html">Distribution.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0092b66fbebee633e8016f625797f05f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar, typename... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef core::splitter&lt;T...&gt;::conditional_type::index_type <a class="el" href="classprob_1_1distribution.html">prob::distribution</a>&lt; Scalar, T &gt;::<a class="el" href="classprob_1_1distribution.html#a0092b66fbebee633e8016f625797f05f">row_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Row extents/indices tuple type. </p>
<p>The tuple type (std::tuple) of the row extents (when denoting the size of the conditional variables) or row indices when denoting a specific event (of the conditional variables). </p>

<p>Definition at line <a class="el" href="_distribution_8hpp_source.html#l00328">328</a> of file <a class="el" href="_distribution_8hpp_source.html">Distribution.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a072f64ca65f96299616a67133264a3b4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar, typename... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprob_1_1distribution.html">prob::distribution</a>&lt; Scalar, T &gt;::<a class="el" href="classprob_1_1distribution.html">distribution</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>For static random variables this is the default constructor that needs to be used. For dynamicly sized random variables the default constructor creates a matrix with empty extents and a one-element vector as backed Eigen matrix. Unless reshape_dimensions is called at least once the matrix should not be used anywhere.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000010">Todo:</a></b></dt><dd>Some way to assert any illicit usage? </dd></dl>

<p>Definition at line <a class="el" href="_distribution_8hpp_source.html#l00479">479</a> of file <a class="el" href="_distribution_8hpp_source.html">Distribution.hpp</a>.</p>
<div class="fragment"><div class="line">                   : <a class="code" href="classprob_1_1distribution.html#a87f265962c64168c63c1e3b222721712" title="Eigen base matrix type.">matrix_type</a>(core::static_row_extents&lt;T...&gt;::size(),</div>
<div class="line">        core::static_col_extents&lt;T...&gt;::size()),</div>
<div class="line">        _row_extents(core::static_row_extents&lt;T...&gt;::extents()),</div>
<div class="line">        _col_extents(core::static_col_extents&lt;T...&gt;::extents())</div>
<div class="line">    {</div>
<div class="line">    }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a693b1bba233c5f450375d373e91583f0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar, typename... T&gt; </div>
<div class="memtemplate">
template&lt;typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprob_1_1distribution.html">prob::distribution</a>&lt; Scalar, T &gt;::<a class="el" href="classprob_1_1distribution.html">distribution</a> </td>
          <td>(</td>
          <td class="paramtype">const S &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprob_1_1distribution.html#a0092b66fbebee633e8016f625797f05f">row_type</a> &amp;&#160;</td>
          <td class="paramname"><em>row_extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprob_1_1distribution.html#acd77ec1aad9829f29e9231068760b365">col_type</a> &amp;&#160;</td>
          <td class="paramname"><em>col_extents</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Quasi copy constructor. </p>
<p>Reshape the distribution but copy the backed matrix (overall dimensions stay fixed). </p>

<p>Definition at line <a class="el" href="_distribution_8hpp_source.html#l00503">503</a> of file <a class="el" href="_distribution_8hpp_source.html">Distribution.hpp</a>.</p>
<div class="fragment"><div class="line">                                     :</div>
<div class="line">        <a class="code" href="classprob_1_1distribution.html#a87f265962c64168c63c1e3b222721712" title="Eigen base matrix type.">matrix_type</a>(other),</div>
<div class="line">        _row_extents(<a class="code" href="classprob_1_1distribution.html#a65688371b7bf210e2a23c31eff38fb5b" title="Alias for conditional_extents.">row_extents</a>),</div>
<div class="line">        _col_extents(<a class="code" href="classprob_1_1distribution.html#a2a4c3140b3bf2ae48923ede6343a483c" title="Alias for posterior_extents.">col_extents</a>)</div>
<div class="line">    {</div>
<div class="line">      <span class="keywordtype">unsigned</span> induced_rows =</div>
<div class="line">          <a class="code" href="namespaceprob_1_1util_1_1tuple.html#a584430ef3c8c36a28fc7f78181e2d03a">util::tuple::fold</a>(</div>
<div class="line">              [] (<span class="keyword">const</span> random_event &amp;a, <span class="keywordtype">int</span> b)</div>
<div class="line">              { <span class="keywordflow">return</span> a._val*b; },</div>
<div class="line">              1,</div>
<div class="line">              <a class="code" href="classprob_1_1distribution.html#a65688371b7bf210e2a23c31eff38fb5b" title="Alias for conditional_extents.">row_extents</a>);</div>
<div class="line">      assert(other.rows() == induced_rows);</div>
<div class="line"></div>
<div class="line">      <span class="keywordtype">unsigned</span> induced_cols =</div>
<div class="line">          <a class="code" href="namespaceprob_1_1util_1_1tuple.html#a584430ef3c8c36a28fc7f78181e2d03a">util::tuple::fold</a>(</div>
<div class="line">              [] (<span class="keyword">const</span> random_event &amp;a, <span class="keywordtype">int</span> b)</div>
<div class="line">              { <span class="keywordflow">return</span> a._val*b; },</div>
<div class="line">              1,</div>
<div class="line">              <a class="code" href="classprob_1_1distribution.html#a2a4c3140b3bf2ae48923ede6343a483c" title="Alias for posterior_extents.">col_extents</a>);</div>
<div class="line">      assert(other.cols() == induced_cols);</div>
   }</div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classprob_1_1distribution_a693b1bba233c5f450375d373e91583f0_cgraph.png" border="0" usemap="#classprob_1_1distribution_a693b1bba233c5f450375d373e91583f0_cgraph" alt=""/></div>
<map name="classprob_1_1distribution_a693b1bba233c5f450375d373e91583f0_cgraph" id="classprob_1_1distribution_a693b1bba233c5f450375d373e91583f0_cgraph">
<area shape="rect" id="node3" href="namespaceprob_1_1util_1_1tuple.html#a584430ef3c8c36a28fc7f78181e2d03a" title="prob::util::tuple::fold" alt="" coords="174,5,311,32"/><area shape="rect" id="node5" href="classprob_1_1distribution.html#a65688371b7bf210e2a23c31eff38fb5b" title="Alias for conditional_extents." alt="" coords="183,57,302,98"/><area shape="rect" id="node7" href="classprob_1_1distribution.html#a2a4c3140b3bf2ae48923ede6343a483c" title="Alias for posterior_extents." alt="" coords="183,122,302,163"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a0fd283aa710f25f2ebd298ee0e23b39f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar, typename... T&gt; </div>
<div class="memtemplate">
template&lt;typename... _T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprob_1_1distribution.html">prob::distribution</a>&lt; Scalar, T &gt;::<a class="el" href="classprob_1_1distribution.html">distribution</a> </td>
          <td>(</td>
          <td class="paramtype">_T...&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for distributions with dynamically sized random variables. </p>
<p>Use this constructor to for distributions that use dynamically sized random variables.</p>
<div class="fragment"><div class="line">RVAR(X)</div>
<div class="line">RVAR(Y)</div>
<div class="line">...</div>
<div class="line"><a class="code" href="classprob_1_1distribution.html#a072f64ca65f96299616a67133264a3b4" title="Default constructor.">distribution</a>&lt;<span class="keywordtype">double</span>, X, given, Y&gt; p(X(10) | Y(5));</div>
</div><!-- fragment --><p>Leads to a compile time error if any of the random variable types is declared as static.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_T...</td><td>Implicit template parameter the expanded type of _T... needs to match the distribution template type T... </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t...</td><td>The extents of each random variable </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_distribution_8hpp_source.html#l00548">548</a> of file <a class="el" href="_distribution_8hpp_source.html">Distribution.hpp</a>.</p>
<div class="fragment"><div class="line">                          :</div>
<div class="line">    <a class="code" href="classprob_1_1distribution.html#a87f265962c64168c63c1e3b222721712" title="Eigen base matrix type.">matrix_type</a>(core::splitter&lt;_T...&gt;::rows(std::forward&lt;_T&gt;(t)...),</div>
<div class="line">        core::splitter&lt;_T...&gt;::cols(std::forward&lt;_T&gt;(t)...)),</div>
<div class="line">        _row_extents(core::splitter&lt;_T...&gt;::row_index(std::forward&lt;_T&gt;(t)...)),</div>
<div class="line">        _col_extents(core::splitter&lt;_T...&gt;::col_index(std::forward&lt;_T&gt;(t)...))</div>
<div class="line">    {</div>
<div class="line">      <span class="comment">// Type to split the type list of the constructor parameters</span></div>
<div class="line">      <span class="keyword">typedef</span> core::splitter&lt;typename std::decay&lt;_T&gt;::type...&gt; local_splitter;</div>
<div class="line"></div>
<div class="line">      <span class="comment">// Called on a distribution of static random variables? If yes, compile time error</span></div>
<div class="line">      extents_assert&lt;T...&gt;::assert_static();</div>
<div class="line"></div>
<div class="line">      <span class="comment">// Also a compile time error if T... (always expanded)</span></div>
<div class="line">      <span class="comment">// does not match _T... (expanded type)</span></div>
<div class="line">      static_assert(util::traits::are_equivalent&lt;typename local_splitter::expanded_type, T...&gt;::value,</div>
<div class="line">          <span class="stringliteral">&quot;Random variable type mismatch&quot;</span>);</div>
   }</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ad9405bb071b23af1b56924eb55d2122b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar, typename... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr bool <a class="el" href="classprob_1_1distribution.html">prob::distribution</a>&lt; Scalar, T &gt;::conditional_distribution </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the distribution a conditional distribution? </p>
<p>This is a compile time property of the type. </p>

<p>Definition at line <a class="el" href="_distribution_8hpp_source.html#l00409">409</a> of file <a class="el" href="_distribution_8hpp_source.html">Distribution.hpp</a>.</p>
<div class="fragment"><div class="line">    {</div>
<div class="line">      <span class="keywordflow">return</span> _conditional_distribution;</div>
<div class="line">    }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a32d8502fd7b43d5261f66423c126aea4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar, typename... T&gt; </div>
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classprob_1_1distribution.html">prob::distribution</a>&lt; Scalar, T &gt;::each_conditional_index </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterate over all conditional variable indices. </p>
<p>This function iterates over each conditional index t... and calls f(t...). The variable indices are incremented with the first conditional variable being in the outer most loop.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>function type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>the function. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_distribution_8hpp_source.html#l01042">1042</a> of file <a class="el" href="_distribution_8hpp_source.html">Distribution.hpp</a>.</p>
<div class="fragment"><div class="line">    {</div>
<div class="line">      <span class="comment">// Different implementations depending on whether the distribution is</span></div>
<div class="line">      <span class="comment">// a conditional or not</span></div>
<div class="line">      cased.each_conditional_index(*<span class="keyword">this</span>,f);</div>
<div class="line">    }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a4333addc3a829eebfe8648b01e17eca0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar, typename... T&gt; </div>
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classprob_1_1distribution.html">prob::distribution</a>&lt; Scalar, T &gt;::each_index </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterate over all variable indices. </p>
<p>This function iterates over each index t... and calls f(t...). The variable indices are incremented with the first variable being in the outer most loop.</p>
<p>Example using a lambda function:</p>
<div class="fragment"><div class="line">distribution&lt;double, X, given, Y&gt; p;</div>
<div class="line">p.each_index([&amp;] (<span class="keyword">const</span> X&amp; x, given, <span class="keyword">const</span> Y&amp; y)</div>
<div class="line">              {</div>
<div class="line">                cout &lt;&lt; x &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; y &lt;&lt; <span class="stringliteral">&quot; : &quot;</span> &lt;&lt; p(x|y);</div>
<div class="line">              });</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>function type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>the function. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_distribution_8hpp_source.html#l00996">996</a> of file <a class="el" href="_distribution_8hpp_source.html">Distribution.hpp</a>.</p>
<div class="fragment"><div class="line">    {</div>
<div class="line">      <span class="comment">// Different implementations depending on whether the distribution is</span></div>
<div class="line">      <span class="comment">// a conditional or not</span></div>
<div class="line">      cased.each_index(*<span class="keyword">this</span>,f);</div>
<div class="line">    }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="abf8d208914da012381733fcbb04bdfde"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar, typename... T&gt; </div>
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classprob_1_1distribution.html">prob::distribution</a>&lt; Scalar, T &gt;::each_index_reverse </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterate over all variable indices with reversed loops. </p>
<p>This function iterates over each index t... and calls f(t...). The variable indices are incremented with the first variable being in the inner most loop.</p>
<p>Example using a lambda function:</p>
<div class="fragment"><div class="line">distribution&lt;double, X, given, Y&gt; p;</div>
<div class="line">p.each_index([&amp;] (<span class="keyword">const</span> X&amp; x, given, <span class="keyword">const</span> Y&amp; y)</div>
<div class="line">              {</div>
<div class="line">                cout &lt;&lt; x &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; y &lt;&lt; <span class="stringliteral">&quot; : &quot;</span> &lt;&lt; p(x|y);</div>
<div class="line">              });</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>function type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>the function. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_distribution_8hpp_source.html#l01024">1024</a> of file <a class="el" href="_distribution_8hpp_source.html">Distribution.hpp</a>.</p>
<div class="fragment"><div class="line">    {</div>
<div class="line">      <span class="comment">// Different implementations depending on whether the distribution is</span></div>
<div class="line">      <span class="comment">// a conditional or not</span></div>
<div class="line">      cased.each_index_reverse(*<span class="keyword">this</span>,f);</div>
<div class="line">    }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a1ccca8825aa6682cce1b03f55ee0837f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar, typename... T&gt; </div>
<div class="memtemplate">
template&lt;int... GroupIndices&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classprob_1_1distribution.html">prob::distribution</a>&lt; Scalar, T &gt;::grouped_map_sum </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; Scalar(Scalar)&gt;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const -&gt; typename type_to_distribution&lt;
		typename core::indexed_type_selector&lt;<a class="el" href="classprob_1_1distribution.html#a75e2d3d5bc94f27c5dd651d90f6bde06">expanded_type</a>,
		core::splitter&lt;T...&gt;::posteriors(),
		core::splitter&lt;T...&gt;::conditionals(),
		-1,
		GroupIndices...&gt;::result_type&gt;::distribution_type
		</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A generalized marginalization method. </p>
<p>Let the random variable type list </p>
<p class="formulaDsp">
\[ T... = X_0,...,X_k, \operatorname{given}, X_{k+1},..., X_{n} \]
</p>
<p> then grouped_map_sum&lt;i_0,...,i_m&gt;, given that \( i_j \leq k \) and \( i_{j+1} \geq k \), applies the function f as follows: </p>
<p class="formulaDsp">
\[ p(x_{i_0}, ..., x_{i_j}| x_{i_{j+1}}, ..., x_{i_m}) = \sum_{x_{l_1}, ..., x_{l_{n-m}}, l_t \notin \{i_0, ... i_m\}} f(p(x_* ...)) \]
</p>
<p> where \( x_* ... \) denotes the merge of the summation indices and the selection indices \( i_0,...,i_m \). </p>

<p>Definition at line <a class="el" href="_distribution_8hpp_source.html#l01173">1173</a> of file <a class="el" href="_distribution_8hpp_source.html">Distribution.hpp</a>.</p>
<div class="fragment"><div class="line">    {</div>
<div class="line">      <span class="comment">// Are any indices out of range? No permutation of posteriors/conditionals?</span></div>
<div class="line">      static_assert(core::check_indices&lt;</div>
<div class="line">          core::splitter&lt;T...&gt;::posteriors(),</div>
<div class="line">          core::splitter&lt;T...&gt;::conditionals(),</div>
<div class="line">          0,</div>
<div class="line">          GroupIndices...&gt;::valid(), <span class="stringliteral">&quot;Variable index out of range&quot;</span>);</div>
<div class="line"></div>
<div class="line">      <span class="comment">// Allows to select a subset of the types T... given by the</span></div>
<div class="line">      <span class="comment">// group indices</span></div>
<div class="line">      <span class="keyword">typedef</span> <span class="keyword">typename</span> core::indexed_type_selector&lt;</div>
<div class="line">          <a class="code" href="classprob_1_1distribution.html#a75e2d3d5bc94f27c5dd651d90f6bde06" title="Random variables type.">expanded_type</a>,</div>
<div class="line">          core::splitter&lt;T...&gt;::posteriors(),</div>
<div class="line">          core::splitter&lt;T...&gt;::conditionals(),</div>
<div class="line">          -1,</div>
<div class="line">          GroupIndices...&gt; type_selector;</div>
<div class="line"></div>
<div class="line">      <span class="comment">// Using the type selector we define the result type</span></div>
<div class="line">      <span class="keyword">typedef</span> <span class="keyword">typename</span> type_to_distribution&lt;typename type_selector::result_type&gt;</div>
<div class="line">      ::distribution_type result_type;</div>
<div class="line"></div>
<div class="line">      <span class="comment">// First we determine the row (conditional) extents</span></div>
<div class="line">      <span class="comment">// of the result type, by selecting a subset</span></div>
<div class="line">      <span class="comment">// of the current row extents</span></div>
<div class="line"></div>
<div class="line">      <span class="comment">// The index splitter splits the group indices</span></div>
<div class="line">      <span class="comment">// between posteriors and conditionals</span></div>
<div class="line">      <span class="keyword">typename</span> result_type::row_type grouped_row_extents =</div>
<div class="line">          <a class="code" href="namespaceprob_1_1util_1_1tuple.html#afda046aba01997f5ba90ea6b08ac8429">util::tuple::subset</a>(_row_extents,</div>
<div class="line">              <span class="keyword">typename</span></div>
<div class="line">              core::index_splitter&lt;<a class="code" href="classprob_1_1distribution.html#a0092b66fbebee633e8016f625797f05f" title="Row extents/indices tuple type.">row_type</a>,</div>
<div class="line">              core::splitter&lt;T...&gt;::posteriors(),</div>
<div class="line">              core::splitter&lt;T...&gt;::conditionals(),</div>
<div class="line">              GroupIndices...&gt;::row_index_type());</div>
<div class="line"></div>
<div class="line">      <span class="comment">/*</span></div>
<div class="line"><span class="comment">      // Then calculate the number of rows of the grouped distribution</span></div>
<div class="line"><span class="comment">      int grouped_rows =</span></div>
<div class="line"><span class="comment">          util::tuple::fold(</span></div>
<div class="line"><span class="comment">              [] (const random_event &amp;a, int b)</span></div>
<div class="line"><span class="comment">              { return a._val*b; },</span></div>
<div class="line"><span class="comment">              1,</span></div>
<div class="line"><span class="comment">              grouped_row_extents);*/</span></div>
<div class="line"></div>
<div class="line">      <span class="comment">// Now we determine the column (posterior) extents</span></div>
<div class="line">      <span class="comment">// of the result type, by selecting a subset</span></div>
<div class="line">      <span class="comment">// of the current column extents</span></div>
<div class="line">      <span class="keyword">typename</span> result_type::col_type grouped_col_extents =</div>
<div class="line">          <a class="code" href="namespaceprob_1_1util_1_1tuple.html#afda046aba01997f5ba90ea6b08ac8429">util::tuple::subset</a>(_col_extents,</div>
<div class="line">              <span class="keyword">typename</span></div>
<div class="line">              core::index_splitter&lt;<a class="code" href="classprob_1_1distribution.html#acd77ec1aad9829f29e9231068760b365" title="Column extents/indices tuple type.">col_type</a>,</div>
<div class="line">              core::splitter&lt;T...&gt;::posteriors(),</div>
<div class="line">              core::splitter&lt;T...&gt;::conditionals(),</div>
<div class="line">              GroupIndices...&gt;::col_index_type());</div>
<div class="line">      <span class="comment">/*</span></div>
<div class="line"><span class="comment">      // And calculate the number of cols of the grouped distribution</span></div>
<div class="line"><span class="comment">      int grouped_cols =</span></div>
<div class="line"><span class="comment">          util::tuple::fold(</span></div>
<div class="line"><span class="comment">              [] (const random_event &amp;a, int b)</span></div>
<div class="line"><span class="comment">              { return a._val*b; },</span></div>
<div class="line"><span class="comment">              1,</span></div>
<div class="line"><span class="comment">              grouped_col_extents);*/</span></div>
<div class="line"></div>
<div class="line">      result_type grouped_dist;</div>
<div class="line">      grouped_dist.reshape_dimensions(</div>
<div class="line">          grouped_row_extents, grouped_col_extents);</div>
<div class="line"></div>
<div class="line">      grouped_dist.setZero();</div>
<div class="line"></div>
<div class="line">      <span class="comment">// Finally sum over all indices that are not group indices</span></div>
<div class="line">      <span class="comment">// and apply f to each value</span></div>
<div class="line">      this-&gt;<a class="code" href="classprob_1_1distribution.html#a4333addc3a829eebfe8648b01e17eca0" title="Iterate over all variable indices.">each_index</a>(</div>
<div class="line">          [<span class="keyword">this</span>, &amp;grouped_dist, &amp;f] (<span class="keyword">const</span> T&amp;... t)</div>
<div class="line">          {</div>
<div class="line">        core::ref&lt;</div>
<div class="line">        <span class="keyword">typename</span> type_selector::index_type,</div>
<div class="line">        double,result_type, T...&gt;::get(grouped_dist, t...) +=</div>
<div class="line">            f(this-&gt;<span class="keyword">operator</span>()(std::forward&lt;const T&amp;&gt;(t)...));</div>
<div class="line">          });</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">return</span> grouped_dist;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classprob_1_1distribution_a1ccca8825aa6682cce1b03f55ee0837f_cgraph.png" border="0" usemap="#classprob_1_1distribution_a1ccca8825aa6682cce1b03f55ee0837f_cgraph" alt=""/></div>
<map name="classprob_1_1distribution_a1ccca8825aa6682cce1b03f55ee0837f_cgraph" id="classprob_1_1distribution_a1ccca8825aa6682cce1b03f55ee0837f_cgraph">
<area shape="rect" id="node3" href="namespaceprob_1_1util_1_1tuple.html#afda046aba01997f5ba90ea6b08ac8429" title="prob::util::tuple::\lsubset" alt="" coords="195,5,311,46"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ae779dbb2a35d94eb8424adb109fa72b9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar, typename... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classprob_1_1distribution.html">distribution</a>&lt;Scalar, T...&gt; <a class="el" href="classprob_1_1distribution.html">prob::distribution</a>&lt; Scalar, T &gt;::load </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load a distribution. </p>
<p>Load a distribution from any std::istream. See here for the distribution format. </p>

<p>Definition at line <a class="el" href="_distribution_8hpp_source.html#l00420">420</a> of file <a class="el" href="_distribution_8hpp_source.html">Distribution.hpp</a>.</p>
<div class="fragment"><div class="line">    {</div>
<div class="line">      <span class="comment">// Ignore the headers</span></div>
<div class="line">      in.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), <span class="charliteral">&#39;\n&#39;</span>);</div>
<div class="line">      in.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), <span class="charliteral">&#39;\n&#39;</span>);</div>
<div class="line"></div>
<div class="line">      <span class="comment">// Read the extents</span></div>
<div class="line">      <span class="keyword">auto</span> full_extents = core::tuple_read&lt;T...&gt;(in);</div>
<div class="line"></div>
<div class="line">      <span class="keyword">auto</span> <a class="code" href="classprob_1_1distribution.html#a2a4c3140b3bf2ae48923ede6343a483c" title="Alias for posterior_extents.">col_extents</a> = <a class="code" href="namespaceprob_1_1util_1_1tuple.html#afda046aba01997f5ba90ea6b08ac8429">util::tuple::subset</a>(full_extents,</div>
<div class="line">                            <span class="keyword">typename</span> util::compile_time_list::iota_0&lt;</div>
<div class="line">                                        core::splitter&lt;T...&gt;::posteriors()&gt;::type());</div>
<div class="line"></div>
<div class="line">      <span class="keyword">auto</span> <a class="code" href="classprob_1_1distribution.html#a65688371b7bf210e2a23c31eff38fb5b" title="Alias for conditional_extents.">row_extents</a> = <a class="code" href="namespaceprob_1_1util_1_1tuple.html#afda046aba01997f5ba90ea6b08ac8429">util::tuple::subset</a>(full_extents,</div>
<div class="line">                                  <span class="keyword">typename</span> util::compile_time_list::iota_n&lt;</div>
<div class="line">                                              core::splitter&lt;T...&gt;::posteriors()+1,</div>
<div class="line">                                              <span class="keyword">sizeof</span>...(T)&gt;::type());</div>
<div class="line"></div>
<div class="line">      <a class="code" href="classprob_1_1distribution.html#a072f64ca65f96299616a67133264a3b4" title="Default constructor.">distribution</a>&lt;Scalar, T...&gt; dist;</div>
<div class="line">      <span class="comment">// In case of a static distribution this should either match or assert</span></div>
<div class="line">      dist.reshape_dimensions(<a class="code" href="classprob_1_1distribution.html#a65688371b7bf210e2a23c31eff38fb5b" title="Alias for conditional_extents.">row_extents</a>, <a class="code" href="classprob_1_1distribution.html#a2a4c3140b3bf2ae48923ede6343a483c" title="Alias for posterior_extents.">col_extents</a>);</div>
<div class="line">      dist.setZero();</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">do</span></div>
<div class="line">      {</div>
<div class="line">        <span class="keyword">auto</span> full_index = core::tuple_read&lt;T...&gt;(in);</div>
<div class="line"></div>
<div class="line">        <span class="keyword">auto</span> col_index = <a class="code" href="namespaceprob_1_1util_1_1tuple.html#afda046aba01997f5ba90ea6b08ac8429">util::tuple::subset</a>(full_index,</div>
<div class="line">                              <span class="keyword">typename</span> util::compile_time_list::iota_0&lt;</div>
<div class="line">                                          core::splitter&lt;T...&gt;::posteriors()&gt;::type());</div>
<div class="line"></div>
<div class="line">        <span class="keyword">auto</span> row_index = <a class="code" href="namespaceprob_1_1util_1_1tuple.html#afda046aba01997f5ba90ea6b08ac8429">util::tuple::subset</a>(full_index,</div>
<div class="line">                                    <span class="keyword">typename</span> util::compile_time_list::iota_n&lt;</div>
<div class="line">                                                core::splitter&lt;T...&gt;::posteriors()+1,</div>
<div class="line">                                                <span class="keyword">sizeof</span>...(T)&gt;::type());</div>
<div class="line"></div>
<div class="line">        in.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), <span class="charliteral">&#39; &#39;</span>);</div>
<div class="line">        in.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), <span class="charliteral">&#39;:&#39;</span>);</div>
<div class="line">        in.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), <span class="charliteral">&#39; &#39;</span>);</div>
<div class="line"></div>
<div class="line">        Scalar v;</div>
<div class="line">        <span class="keywordflow">if</span>(!(in&gt;&gt;v))</div>
<div class="line">          <span class="keywordflow">break</span>;</div>
<div class="line">        dist.prob_ref_via_tuple(row_index, col_index) = v;</div>
<div class="line">      } <span class="keywordflow">while</span>(<span class="keyword">true</span>);</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">return</span> dist;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classprob_1_1distribution_ae779dbb2a35d94eb8424adb109fa72b9_cgraph.png" border="0" usemap="#classprob_1_1distribution_ae779dbb2a35d94eb8424adb109fa72b9_cgraph" alt=""/></div>
<map name="classprob_1_1distribution_ae779dbb2a35d94eb8424adb109fa72b9_cgraph" id="classprob_1_1distribution_ae779dbb2a35d94eb8424adb109fa72b9_cgraph">
<area shape="rect" id="node3" href="classprob_1_1distribution.html#a2a4c3140b3bf2ae48923ede6343a483c" title="Alias for posterior_extents." alt="" coords="189,5,307,46"/><area shape="rect" id="node5" href="namespaceprob_1_1util_1_1tuple.html#afda046aba01997f5ba90ea6b08ac8429" title="prob::util::tuple::\lsubset" alt="" coords="190,70,306,111"/><area shape="rect" id="node7" href="classprob_1_1distribution.html#a65688371b7bf210e2a23c31eff38fb5b" title="Alias for conditional_extents." alt="" coords="189,135,307,177"/><area shape="rect" id="node9" href="classprob_1_1distribution.html#a894a0c5da26697111aab42be99deeba1" title="Reshape the extents of the distribution." alt="" coords="173,201,323,242"/><area shape="rect" id="node13" href="classprob_1_1distribution.html#ab9a29235904c048b6c8363fb0ccbc65e" title="Get a probability reference using two index tuples." alt="" coords="180,266,316,307"/><area shape="rect" id="node11" href="namespaceprob_1_1util_1_1tuple.html#a584430ef3c8c36a28fc7f78181e2d03a" title="prob::util::tuple::fold" alt="" coords="371,216,509,243"/><area shape="rect" id="node16" href="namespaceprob_1_1util_1_1tuple.html#aecc18057ca8bb5b82f2d5e1a377e8414" title="prob::util::tuple::zip" alt="" coords="373,273,507,300"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="af9a9904a0d545203c94a77efd0cf08e7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar, typename... T&gt; </div>
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprob_1_1distribution.html">distribution</a>&amp; <a class="el" href="classprob_1_1distribution.html">prob::distribution</a>&lt; Scalar, T &gt;::map </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply a function to each probability value. </p>
<p>The function f only gets the probabilities not the indices. This method returns the mutated distribution. </p>

<p>Definition at line <a class="el" href="_distribution_8hpp_source.html#l01095">1095</a> of file <a class="el" href="_distribution_8hpp_source.html">Distribution.hpp</a>.</p>
<div class="fragment"><div class="line">    {</div>
<div class="line">      <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i=0;i&lt;matrix_type::rows();++i)</div>
<div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> j=0;j&lt;matrix_type::cols();++j)</div>
<div class="line">          matrix_type::operator()(i,j) = f(matrix_type::operator()(i,j));</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">    }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a74565d39808a14314ae10cc69efa0dad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar, typename... T&gt; </div>
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprob_1_1distribution.html">distribution</a>&amp; <a class="el" href="classprob_1_1distribution.html">prob::distribution</a>&lt; Scalar, T &gt;::map_by_conditional </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply a function to each posterior distribution. </p>
<p>The function f only gets the posterior distribution not the indices of the conditional. This method returns the mutated distribution. </p>

<p>Definition at line <a class="el" href="_distribution_8hpp_source.html#l01127">1127</a> of file <a class="el" href="_distribution_8hpp_source.html">Distribution.hpp</a>.</p>
<div class="fragment"><div class="line">    {</div>
<div class="line">      <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i=0;i&lt;matrix_type::rows();++i)</div>
<div class="line">      {</div>
<div class="line">        matrix_type::row(i) =</div>
<div class="line">            f(<a class="code" href="classprob_1_1distribution.html#a7c6e563439d1a53548f824b169108e01" title="Posterior distribution type.">posterior_distribution_type</a>(matrix_type::row(i),</div>
<div class="line">                std::make_tuple&lt;&gt;(),</div>
<div class="line">                _col_extents));</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">    }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="abe414bb30baa0141c643ba688835a1cc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar, typename... T&gt; </div>
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprob_1_1distribution.html">distribution</a> <a class="el" href="classprob_1_1distribution.html">prob::distribution</a>&lt; Scalar, T &gt;::map_copy </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply a function to a copy of each probability value. </p>
<p>The function f only gets the probabilities not the indices. This method returns a distribution of the same tyoe. </p>

<p>Definition at line <a class="el" href="_distribution_8hpp_source.html#l01111">1111</a> of file <a class="el" href="_distribution_8hpp_source.html">Distribution.hpp</a>.</p>
<div class="fragment"><div class="line">    {</div>
<div class="line">      <a class="code" href="classprob_1_1distribution.html#a87f265962c64168c63c1e3b222721712" title="Eigen base matrix type.">matrix_type</a> mapped(matrix_type::rows(),matrix_type::cols());</div>
<div class="line">      <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i=0;i&lt;matrix_type::rows();++i)</div>
<div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> j=0;j&lt;matrix_type::cols();++j)</div>
<div class="line">          mapped(i,j) = f(matrix_type::operator()(i,j));</div>
<div class="line">      <span class="keywordflow">return</span> <a class="code" href="classprob_1_1distribution.html#a072f64ca65f96299616a67133264a3b4" title="Default constructor.">distribution</a>(mapped, _row_extents, _col_extents);</div>
<div class="line">    }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a8648fb1ae7da31fa2553e918f07e448b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar, typename... T&gt; </div>
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprob_1_1distribution.html">distribution</a> <a class="el" href="classprob_1_1distribution.html">prob::distribution</a>&lt; Scalar, T &gt;::map_copy_by_conditional </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply a function to a copy of each posterior distribution. </p>
<p>This method returns a distribution of the same type. </p>

<p>Definition at line <a class="el" href="_distribution_8hpp_source.html#l01146">1146</a> of file <a class="el" href="_distribution_8hpp_source.html">Distribution.hpp</a>.</p>
<div class="fragment"><div class="line">    {</div>
<div class="line">      <a class="code" href="classprob_1_1distribution.html#a87f265962c64168c63c1e3b222721712" title="Eigen base matrix type.">matrix_type</a> mapped(matrix_type::rows(), matrix_type::cols());</div>
<div class="line">      <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i=0;i&lt;matrix_type::rows();++i)</div>
<div class="line">      {</div>
<div class="line">        mapped.row(i) =</div>
<div class="line">            f(<a class="code" href="classprob_1_1distribution.html#a7c6e563439d1a53548f824b169108e01" title="Posterior distribution type.">posterior_distribution_type</a>(matrix_type::row(i),</div>
<div class="line">                std::make_tuple&lt;&gt;(),</div>
<div class="line">                _col_extents));</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">return</span> <a class="code" href="classprob_1_1distribution.html#a072f64ca65f96299616a67133264a3b4" title="Default constructor.">distribution</a>(mapped, _row_extents, _col_extents);</div>
<div class="line">    }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a6fe42bfd07878e6555dc124aafdb7968"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar, typename... T&gt; </div>
<div class="memtemplate">
template&lt;typename... _T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Scalar <a class="el" href="classprob_1_1distribution.html">prob::distribution</a>&lt; Scalar, T &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">_T...&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a probability value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_T...</td><td>Implicit template parameter, the expansion of the type list needs to match T... </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t...</td><td>Index of the probability </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Probability value </dd></dl>

<p>Definition at line <a class="el" href="_distribution_8hpp_source.html#l00893">893</a> of file <a class="el" href="_distribution_8hpp_source.html">Distribution.hpp</a>.</p>
<div class="fragment"><div class="line">    {</div>
<div class="line">      <span class="comment">// Splits the methods argument type lists</span></div>
<div class="line">      <span class="keyword">typedef</span> core::splitter&lt;typename std::decay&lt;_T&gt;::type...&gt; local_splitter;</div>
<div class="line"></div>
<div class="line">      <span class="comment">// Compile time error if T... does not match _T... (expanded type)</span></div>
<div class="line">      static_assert(util::traits::are_equivalent&lt;</div>
<div class="line">          <span class="keyword">typename</span> local_splitter::expanded_type, T...&gt;::value,</div>
<div class="line">          <span class="stringliteral">&quot;Random variable type mismatch&quot;</span>);</div>
<div class="line"></div>
<div class="line">      <span class="comment">// Get the conditional indices of the arguments</span></div>
<div class="line">      <a class="code" href="classprob_1_1distribution.html#a0092b66fbebee633e8016f625797f05f" title="Row extents/indices tuple type.">row_type</a> row_index(</div>
<div class="line">          local_splitter::row_index(</div>
<div class="line">              std::forward&lt;<span class="keyword">typename</span> std::decay&lt;_T&gt;::type&gt;(t)...));</div>
<div class="line"></div>
<div class="line">      <span class="comment">// Get the posterior indices of the arguments</span></div>
<div class="line">      <a class="code" href="classprob_1_1distribution.html#acd77ec1aad9829f29e9231068760b365" title="Column extents/indices tuple type.">col_type</a> col_index(</div>
<div class="line">          local_splitter::col_index(</div>
<div class="line">              std::forward&lt;<span class="keyword">typename</span> std::decay&lt;_T&gt;::type&gt;(t)...));</div>
<div class="line"></div>
<div class="line">      <span class="keywordtype">int</span> row, col;</div>
<div class="line"></div>
<div class="line">      <span class="comment">// Use the default accumulator to calculate row and column index</span></div>
<div class="line">      row = std::get&lt;0&gt;(<a class="code" href="namespaceprob_1_1util_1_1tuple.html#a584430ef3c8c36a28fc7f78181e2d03a">util::tuple::fold</a>(</div>
<div class="line">          core::element_index_accu,</div>
<div class="line">          std::make_tuple(0,1),</div>
<div class="line">          <a class="code" href="namespaceprob_1_1util_1_1tuple.html#aecc18057ca8bb5b82f2d5e1a377e8414">util::tuple::zip</a>(row_index,_row_extents)));</div>
<div class="line"></div>
<div class="line">      col = std::get&lt;0&gt;(<a class="code" href="namespaceprob_1_1util_1_1tuple.html#a584430ef3c8c36a28fc7f78181e2d03a">util::tuple::fold</a>(</div>
<div class="line">          core::element_index_accu,</div>
<div class="line">          std::make_tuple(0,1),</div>
<div class="line">          <a class="code" href="namespaceprob_1_1util_1_1tuple.html#aecc18057ca8bb5b82f2d5e1a377e8414">util::tuple::zip</a>(col_index,_col_extents)));</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">return</span> matrix_type::operator()(row,col);</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classprob_1_1distribution_a6fe42bfd07878e6555dc124aafdb7968_cgraph.png" border="0" usemap="#classprob_1_1distribution_a6fe42bfd07878e6555dc124aafdb7968_cgraph" alt=""/></div>
<map name="classprob_1_1distribution_a6fe42bfd07878e6555dc124aafdb7968_cgraph" id="classprob_1_1distribution_a6fe42bfd07878e6555dc124aafdb7968_cgraph">
<area shape="rect" id="node3" href="namespaceprob_1_1util_1_1tuple.html#a584430ef3c8c36a28fc7f78181e2d03a" title="prob::util::tuple::fold" alt="" coords="174,5,311,32"/><area shape="rect" id="node5" href="namespaceprob_1_1util_1_1tuple.html#aecc18057ca8bb5b82f2d5e1a377e8414" title="prob::util::tuple::zip" alt="" coords="176,56,309,83"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ab2fe90cdf900d44bdbcf4a19a54a6274"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar, typename... T&gt; </div>
<div class="memtemplate">
template&lt;typename... _T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprob_1_1distribution.html#a7c6e563439d1a53548f824b169108e01">posterior_distribution_type</a> <a class="el" href="classprob_1_1distribution.html">prob::distribution</a>&lt; Scalar, T &gt;::posterior_distribution </td>
          <td>(</td>
          <td class="paramtype">_T &amp;&amp;...&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a conditioned posterior distribution. </p>
<p>Results in a compiler error if called on a non-conditional distribution.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_T...</td><td>Implicit template parameter, the expansion of the type list needs to match the posterior variable type list of T... (i.e. _T... = Y... for T = X..., given, Y...). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t...</td><td>Conditional indices \( y... \) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Posterior distribution \( p(\cdot | y...) \) </dd></dl>

<p>Definition at line <a class="el" href="_distribution_8hpp_source.html#l00950">950</a> of file <a class="el" href="_distribution_8hpp_source.html">Distribution.hpp</a>.</p>
<div class="fragment"><div class="line">    {</div>
<div class="line">      <span class="comment">// Compile time error if T... does not match _T... (expanded type)</span></div>
<div class="line">      static_assert(util::traits::are_equivalent&lt;<a class="code" href="classprob_1_1distribution.html#a1dd34cc3e39b2ed244f0fcc50b458827" title="Conditional variables type type.">conditional_type</a>,</div>
<div class="line">          <span class="keyword">typename</span> std::decay&lt;_T&gt;::type...&gt;::value,</div>
<div class="line">          <span class="stringliteral">&quot;Random variable type mismatch&quot;</span>);</div>
<div class="line"></div>
<div class="line">      static_assert(_conditional_distribution, <span class="stringliteral">&quot;Not a conditional distribution&quot;</span>);</div>
<div class="line"></div>
<div class="line">      <span class="comment">// The row index does not need to be extracted here, we just make a tuple</span></div>
<div class="line">      <a class="code" href="classprob_1_1distribution.html#a0092b66fbebee633e8016f625797f05f" title="Row extents/indices tuple type.">row_type</a> row_index = std::make_tuple(t...);</div>
<div class="line"></div>
<div class="line">      <span class="keywordtype">int</span> row;</div>
<div class="line"></div>
<div class="line">      <span class="comment">// Again fold index and extents</span></div>
<div class="line">      row = std::get&lt;0&gt;(<a class="code" href="namespaceprob_1_1util_1_1tuple.html#a584430ef3c8c36a28fc7f78181e2d03a">util::tuple::fold</a>(</div>
<div class="line">          core::element_index_accu,</div>
<div class="line">          std::make_tuple(0,1),</div>
<div class="line">          <a class="code" href="namespaceprob_1_1util_1_1tuple.html#aecc18057ca8bb5b82f2d5e1a377e8414">util::tuple::zip</a>(row_index,_row_extents)));</div>
<div class="line"></div>
<div class="line">      <span class="comment">// Return the row of the matrix as the posterior distribution type with</span></div>
<div class="line">      <span class="comment">// corresponding extents</span></div>
<div class="line">      <span class="keywordflow">return</span> <a class="code" href="classprob_1_1distribution.html#a7c6e563439d1a53548f824b169108e01" title="Posterior distribution type.">posterior_distribution_type</a>(matrix_type::row(row), std::make_tuple&lt;&gt;(), _col_extents);</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classprob_1_1distribution_ab2fe90cdf900d44bdbcf4a19a54a6274_cgraph.png" border="0" usemap="#classprob_1_1distribution_ab2fe90cdf900d44bdbcf4a19a54a6274_cgraph" alt=""/></div>
<map name="classprob_1_1distribution_ab2fe90cdf900d44bdbcf4a19a54a6274_cgraph" id="classprob_1_1distribution_ab2fe90cdf900d44bdbcf4a19a54a6274_cgraph">
<area shape="rect" id="node3" href="namespaceprob_1_1util_1_1tuple.html#a584430ef3c8c36a28fc7f78181e2d03a" title="prob::util::tuple::fold" alt="" coords="206,5,343,32"/><area shape="rect" id="node5" href="namespaceprob_1_1util_1_1tuple.html#aecc18057ca8bb5b82f2d5e1a377e8414" title="prob::util::tuple::zip" alt="" coords="208,56,341,83"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a0b9469252e82c6af3845bb94b5d3695d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar, typename... T&gt; </div>
<div class="memtemplate">
template&lt;typename... _T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Scalar <a class="el" href="classprob_1_1distribution.html">prob::distribution</a>&lt; Scalar, T &gt;::prob_read_or_zero </td>
          <td>(</td>
          <td class="paramtype">_T &amp;&amp;...&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a probability value. </p>
<p>Similar to prob_ref unless that in case of an out of bounds access Scalar(0) is returned.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_T...</td><td>Implicit template parameter, the expansion of the type list needs to match T... </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t...</td><td>Index of the probability </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Probability or Scalar(0) in case of out of bounds access </dd></dl>

<p>Definition at line <a class="el" href="_distribution_8hpp_source.html#l00726">726</a> of file <a class="el" href="_distribution_8hpp_source.html">Distribution.hpp</a>.</p>
<div class="fragment"><div class="line">    {</div>
<div class="line">      <span class="comment">// Splits the methods argument type lists</span></div>
<div class="line">      <span class="keyword">typedef</span> core::splitter&lt;typename std::decay&lt;_T&gt;::type...&gt; local_splitter;</div>
<div class="line"></div>
<div class="line">      <span class="comment">// Compile time error if T... does not match _T... (expanded type)</span></div>
<div class="line">      static_assert(util::traits::are_equivalent&lt;</div>
<div class="line">          <span class="keyword">typename</span> local_splitter::expanded_type, T...&gt;::value,</div>
<div class="line">          <span class="stringliteral">&quot;Random variable type mismatch&quot;</span>);</div>
<div class="line"></div>
<div class="line">      <span class="comment">// Get the conditional indices of the arguments</span></div>
<div class="line">      <a class="code" href="classprob_1_1distribution.html#a0092b66fbebee633e8016f625797f05f" title="Row extents/indices tuple type.">row_type</a> row_index(</div>
<div class="line">          local_splitter::row_index(</div>
<div class="line">              std::forward&lt;<span class="keyword">typename</span> std::decay&lt;_T&gt;::type&gt;(t)...));</div>
<div class="line"></div>
<div class="line">      <span class="comment">// Get the posterior indices of the arguments</span></div>
<div class="line">      <a class="code" href="classprob_1_1distribution.html#acd77ec1aad9829f29e9231068760b365" title="Column extents/indices tuple type.">col_type</a> col_index(</div>
<div class="line">          local_splitter::col_index(</div>
<div class="line">              std::forward&lt;<span class="keyword">typename</span> std::decay&lt;_T&gt;::type&gt;(t)...));</div>
<div class="line"></div>
<div class="line">      <span class="keywordtype">int</span> row, col;</div>
<div class="line">      <span class="keywordtype">bool</span> out_of_bounds=<span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line">      <span class="comment">// Fold accumulator that creates the row, column index from the</span></div>
<div class="line">      <span class="comment">// conditional/posterior indices and extents this check for out of bounds</span></div>
<div class="line">      <span class="comment">// access</span></div>
<div class="line">      <span class="keyword">auto</span> f = [&amp;out_of_bounds] (<span class="keyword">const</span> std::tuple&lt;random_event, random_event&gt;&amp; t,</div>
<div class="line">          std::tuple&lt;int,int&gt; u)</div>
<div class="line">          -&gt; std::tuple&lt;int,int&gt;</div>
<div class="line">      {</div>
<div class="line">        <span class="comment">// Get the accumulated index and extent</span></div>
<div class="line">        <span class="keywordtype">int</span> lastExtent = std::get&lt;1&gt;(u);</div>
<div class="line">        <span class="keywordtype">int</span> lastIndex = std::get&lt;0&gt;(u);</div>
<div class="line">        <span class="comment">// Get the index and extent of the next random variable</span></div>
<div class="line">        <span class="keywordtype">int</span> curExtent = read_index&lt;random_event&gt;::read(std::get&lt;1&gt;(t));</div>
<div class="line">        <span class="keywordtype">int</span> curIndex = read_index&lt;random_event&gt;::read(std::get&lt;0&gt;(t));</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Assertion on any out of bounds access</span></div>
<div class="line">        <span class="keywordflow">if</span>(curIndex &lt; 0 || curIndex &gt;= curExtent)</div>
<div class="line">          out_of_bounds = <span class="keyword">true</span>;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Return the accumulated index and extent</span></div>
<div class="line">        <span class="keywordflow">return</span> std::make_tuple(</div>
<div class="line">            lastExtent * curIndex + lastIndex,</div>
<div class="line">            lastExtent * curExtent);</div>
<div class="line">      };</div>
<div class="line"></div>
<div class="line">      <span class="comment">// Use f to calculate row and column index</span></div>
<div class="line">      row = std::get&lt;0&gt;(<a class="code" href="namespaceprob_1_1util_1_1tuple.html#a584430ef3c8c36a28fc7f78181e2d03a">util::tuple::fold</a>(</div>
<div class="line">          f,</div>
<div class="line">          std::make_tuple(0,1),</div>
<div class="line">          <a class="code" href="namespaceprob_1_1util_1_1tuple.html#aecc18057ca8bb5b82f2d5e1a377e8414">util::tuple::zip</a>(row_index,_row_extents)));</div>
<div class="line"></div>
<div class="line">      col = std::get&lt;0&gt;(<a class="code" href="namespaceprob_1_1util_1_1tuple.html#a584430ef3c8c36a28fc7f78181e2d03a">util::tuple::fold</a>(</div>
<div class="line">          f,</div>
<div class="line">          std::make_tuple(0,1),</div>
<div class="line">          <a class="code" href="namespaceprob_1_1util_1_1tuple.html#aecc18057ca8bb5b82f2d5e1a377e8414">util::tuple::zip</a>(col_index,_col_extents)));</div>
<div class="line"></div>
<div class="line">      <span class="comment">// Out of bounds reads a 0</span></div>
<div class="line">      <span class="keywordflow">if</span>(out_of_bounds)</div>
<div class="line">        <span class="keywordflow">return</span> Scalar(0);</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">return</span> matrix_type::operator()(row,col);</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classprob_1_1distribution_a0b9469252e82c6af3845bb94b5d3695d_cgraph.png" border="0" usemap="#classprob_1_1distribution_a0b9469252e82c6af3845bb94b5d3695d_cgraph" alt=""/></div>
<map name="classprob_1_1distribution_a0b9469252e82c6af3845bb94b5d3695d_cgraph" id="classprob_1_1distribution_a0b9469252e82c6af3845bb94b5d3695d_cgraph">
<area shape="rect" id="node3" href="namespaceprob_1_1util_1_1tuple.html#a584430ef3c8c36a28fc7f78181e2d03a" title="prob::util::tuple::fold" alt="" coords="193,5,330,32"/><area shape="rect" id="node5" href="namespaceprob_1_1util_1_1tuple.html#aecc18057ca8bb5b82f2d5e1a377e8414" title="prob::util::tuple::zip" alt="" coords="195,56,328,83"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a9bc0e71ef75c54c780dd6d84f277a7c0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar, typename... T&gt; </div>
<div class="memtemplate">
template&lt;typename... _T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Scalar&amp; <a class="el" href="classprob_1_1distribution.html">prob::distribution</a>&lt; Scalar, T &gt;::prob_ref </td>
          <td>(</td>
          <td class="paramtype">_T...&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a probability reference. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_T...</td><td>Implicit template parameter, the expansion of the type list needs to match T... </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t...</td><td>Index of the probability </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the probability </dd></dl>

<p>Definition at line <a class="el" href="_distribution_8hpp_source.html#l00849">849</a> of file <a class="el" href="_distribution_8hpp_source.html">Distribution.hpp</a>.</p>
<div class="fragment"><div class="line">    {</div>
<div class="line">      <span class="comment">// Splits the methods argument type lists</span></div>
<div class="line">      <span class="keyword">typedef</span> core::splitter&lt;typename std::decay&lt;_T&gt;::type...&gt; local_splitter;</div>
<div class="line"></div>
<div class="line">      <span class="comment">// Compile time error if T... does not match _T... (expanded type)</span></div>
<div class="line">      static_assert(util::traits::are_equivalent&lt;</div>
<div class="line">          <span class="keyword">typename</span> local_splitter::expanded_type, T...&gt;::value,</div>
<div class="line">          <span class="stringliteral">&quot;Random variable type mismatch&quot;</span>);</div>
<div class="line"></div>
<div class="line">      <span class="comment">// Get the conditional indices of the arguments</span></div>
<div class="line">      <a class="code" href="classprob_1_1distribution.html#a0092b66fbebee633e8016f625797f05f" title="Row extents/indices tuple type.">row_type</a> row_index(</div>
<div class="line">          local_splitter::row_index(</div>
<div class="line">              std::forward&lt;<span class="keyword">typename</span> std::decay&lt;_T&gt;::type&gt;(t)...));</div>
<div class="line"></div>
<div class="line">      <span class="comment">// Get the posterior indices of the arguments</span></div>
<div class="line">      <a class="code" href="classprob_1_1distribution.html#acd77ec1aad9829f29e9231068760b365" title="Column extents/indices tuple type.">col_type</a> col_index(</div>
<div class="line">          local_splitter::col_index(</div>
<div class="line">              std::forward&lt;<span class="keyword">typename</span> std::decay&lt;_T&gt;::type&gt;(t)...));</div>
<div class="line"></div>
<div class="line">      <span class="keywordtype">int</span> row, col;</div>
<div class="line"></div>
<div class="line">      <span class="comment">// Use the default accumulator to calculate row and column index</span></div>
<div class="line">      row = std::get&lt;0&gt;(<a class="code" href="namespaceprob_1_1util_1_1tuple.html#a584430ef3c8c36a28fc7f78181e2d03a">util::tuple::fold</a>(</div>
<div class="line">          core::element_index_accu,</div>
<div class="line">          std::make_tuple(0,1),</div>
<div class="line">          <a class="code" href="namespaceprob_1_1util_1_1tuple.html#aecc18057ca8bb5b82f2d5e1a377e8414">util::tuple::zip</a>(row_index,_row_extents)));</div>
<div class="line"></div>
<div class="line">      col = std::get&lt;0&gt;(<a class="code" href="namespaceprob_1_1util_1_1tuple.html#a584430ef3c8c36a28fc7f78181e2d03a">util::tuple::fold</a>(</div>
<div class="line">          core::element_index_accu,</div>
<div class="line">          std::make_tuple(0,1),</div>
<div class="line">          <a class="code" href="namespaceprob_1_1util_1_1tuple.html#aecc18057ca8bb5b82f2d5e1a377e8414">util::tuple::zip</a>(col_index,_col_extents)));</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">return</span> matrix_type::operator()(row,col);</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classprob_1_1distribution_a9bc0e71ef75c54c780dd6d84f277a7c0_cgraph.png" border="0" usemap="#classprob_1_1distribution_a9bc0e71ef75c54c780dd6d84f277a7c0_cgraph" alt=""/></div>
<map name="classprob_1_1distribution_a9bc0e71ef75c54c780dd6d84f277a7c0_cgraph" id="classprob_1_1distribution_a9bc0e71ef75c54c780dd6d84f277a7c0_cgraph">
<area shape="rect" id="node3" href="namespaceprob_1_1util_1_1tuple.html#a584430ef3c8c36a28fc7f78181e2d03a" title="prob::util::tuple::fold" alt="" coords="174,5,311,32"/><area shape="rect" id="node5" href="namespaceprob_1_1util_1_1tuple.html#aecc18057ca8bb5b82f2d5e1a377e8414" title="prob::util::tuple::zip" alt="" coords="176,56,309,83"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ab9a29235904c048b6c8363fb0ccbc65e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar, typename... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Scalar&amp; <a class="el" href="classprob_1_1distribution.html">prob::distribution</a>&lt; Scalar, T &gt;::prob_ref_via_tuple </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprob_1_1distribution.html#a0092b66fbebee633e8016f625797f05f">row_type</a> &amp;&#160;</td>
          <td class="paramname"><em>row_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprob_1_1distribution.html#acd77ec1aad9829f29e9231068760b365">col_type</a> &amp;&#160;</td>
          <td class="paramname"><em>col_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a probability reference using two index tuples. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row_index</td><td>The index tuple of the conditional events </td></tr>
    <tr><td class="paramname">row_index</td><td>The index tuple of the posterior events </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the probability </dd></dl>

<p>Definition at line <a class="el" href="_distribution_8hpp_source.html#l00798">798</a> of file <a class="el" href="_distribution_8hpp_source.html">Distribution.hpp</a>.</p>
<div class="fragment"><div class="line">    {</div>
<div class="line">      <span class="keywordtype">int</span> row, col;</div>
<div class="line"></div>
<div class="line">      <span class="comment">// Use the default accumulator to calculate row and column index</span></div>
<div class="line">      row = std::get&lt;0&gt;(<a class="code" href="namespaceprob_1_1util_1_1tuple.html#a584430ef3c8c36a28fc7f78181e2d03a">util::tuple::fold</a>(</div>
<div class="line">          core::element_index_accu,</div>
<div class="line">          std::make_tuple(0,1),</div>
<div class="line">          <a class="code" href="namespaceprob_1_1util_1_1tuple.html#aecc18057ca8bb5b82f2d5e1a377e8414">util::tuple::zip</a>(row_index,_row_extents)));</div>
<div class="line"></div>
<div class="line">      col = std::get&lt;0&gt;(<a class="code" href="namespaceprob_1_1util_1_1tuple.html#a584430ef3c8c36a28fc7f78181e2d03a">util::tuple::fold</a>(</div>
<div class="line">          core::element_index_accu,</div>
<div class="line">          std::make_tuple(0,1),</div>
<div class="line">          <a class="code" href="namespaceprob_1_1util_1_1tuple.html#aecc18057ca8bb5b82f2d5e1a377e8414">util::tuple::zip</a>(col_index,_col_extents)));</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">return</span> matrix_type::operator()(row,col);</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classprob_1_1distribution_ab9a29235904c048b6c8363fb0ccbc65e_cgraph.png" border="0" usemap="#classprob_1_1distribution_ab9a29235904c048b6c8363fb0ccbc65e_cgraph" alt=""/></div>
<map name="classprob_1_1distribution_ab9a29235904c048b6c8363fb0ccbc65e_cgraph" id="classprob_1_1distribution_ab9a29235904c048b6c8363fb0ccbc65e_cgraph">
<area shape="rect" id="node3" href="namespaceprob_1_1util_1_1tuple.html#a584430ef3c8c36a28fc7f78181e2d03a" title="prob::util::tuple::fold" alt="" coords="190,5,327,32"/><area shape="rect" id="node5" href="namespaceprob_1_1util_1_1tuple.html#aecc18057ca8bb5b82f2d5e1a377e8414" title="prob::util::tuple::zip" alt="" coords="192,56,325,83"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a42f3b635a1252ee58dd34e9174c19787"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar, typename... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Scalar <a class="el" href="classprob_1_1distribution.html">prob::distribution</a>&lt; Scalar, T &gt;::prob_via_tuple </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprob_1_1distribution.html#a0092b66fbebee633e8016f625797f05f">row_type</a> &amp;&#160;</td>
          <td class="paramname"><em>row_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprob_1_1distribution.html#acd77ec1aad9829f29e9231068760b365">col_type</a> &amp;&#160;</td>
          <td class="paramname"><em>col_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a probability using two index tuples. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row_index</td><td>The index tuple of the conditional events </td></tr>
    <tr><td class="paramname">row_index</td><td>The index tuple of the posterior events </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the probability </dd></dl>

<p>Definition at line <a class="el" href="_distribution_8hpp_source.html#l00823">823</a> of file <a class="el" href="_distribution_8hpp_source.html">Distribution.hpp</a>.</p>
<div class="fragment"><div class="line">    {</div>
<div class="line">      <span class="keywordtype">int</span> row, col;</div>
<div class="line"></div>
<div class="line">      <span class="comment">// Use the default accumulator to calculate row and column index</span></div>
<div class="line">      row = std::get&lt;0&gt;(<a class="code" href="namespaceprob_1_1util_1_1tuple.html#a584430ef3c8c36a28fc7f78181e2d03a">util::tuple::fold</a>(</div>
<div class="line">          core::element_index_accu,</div>
<div class="line">          std::make_tuple(0,1),</div>
<div class="line">          <a class="code" href="namespaceprob_1_1util_1_1tuple.html#aecc18057ca8bb5b82f2d5e1a377e8414">util::tuple::zip</a>(row_index,_row_extents)));</div>
<div class="line"></div>
<div class="line">      col = std::get&lt;0&gt;(<a class="code" href="namespaceprob_1_1util_1_1tuple.html#a584430ef3c8c36a28fc7f78181e2d03a">util::tuple::fold</a>(</div>
<div class="line">          core::element_index_accu,</div>
<div class="line">          std::make_tuple(0,1),</div>
<div class="line">          <a class="code" href="namespaceprob_1_1util_1_1tuple.html#aecc18057ca8bb5b82f2d5e1a377e8414">util::tuple::zip</a>(col_index,_col_extents)));</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">return</span> matrix_type::operator()(row,col);</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classprob_1_1distribution_a42f3b635a1252ee58dd34e9174c19787_cgraph.png" border="0" usemap="#classprob_1_1distribution_a42f3b635a1252ee58dd34e9174c19787_cgraph" alt=""/></div>
<map name="classprob_1_1distribution_a42f3b635a1252ee58dd34e9174c19787_cgraph" id="classprob_1_1distribution_a42f3b635a1252ee58dd34e9174c19787_cgraph">
<area shape="rect" id="node3" href="namespaceprob_1_1util_1_1tuple.html#a584430ef3c8c36a28fc7f78181e2d03a" title="prob::util::tuple::fold" alt="" coords="174,5,311,32"/><area shape="rect" id="node5" href="namespaceprob_1_1util_1_1tuple.html#aecc18057ca8bb5b82f2d5e1a377e8414" title="prob::util::tuple::zip" alt="" coords="176,56,309,83"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a4c1a6743807a2a7980fbdeb690bc8236"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar, typename... T&gt; </div>
<div class="memtemplate">
template&lt;typename... _T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classprob_1_1distribution.html">prob::distribution</a>&lt; Scalar, T &gt;::reshape </td>
          <td>(</td>
          <td class="paramtype">_T &amp;&amp;...&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reshape the extents of the distribution. </p>
<p>Reshapes a distribution of dynamically sized random variables, results in a compile time error if called on staticly sized distributions. If you do not know what your distribution might be, and there is no actual reshaping involved if static random variables are supplied use reshape_dimensions.</p>
<p>The reshaping conserved the probability values if possible. For an extensions, new indices are set to probability 0 and exisitng indices are retained. The resulting distribution is then normalized. If all extents are extended then all probabilities are retained otherwise, values are changed due to renormalization.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_T...</td><td>Implicit template parameter, the expansion of the type list needs to match T... </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t...</td><td>New extents </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_distribution_8hpp_source.html#l00678">678</a> of file <a class="el" href="_distribution_8hpp_source.html">Distribution.hpp</a>.</p>
<div class="fragment"><div class="line">    {</div>
<div class="line">      <span class="comment">// Splits the methods argument type lists</span></div>
<div class="line">      <span class="keyword">typedef</span> core::splitter&lt;typename std::decay&lt;_T&gt;::type...&gt; local_splitter;</div>
<div class="line"></div>
<div class="line">      <span class="comment">// Contrary to reshape_dimensions, this cannot be called on</span></div>
<div class="line">      <span class="comment">// a distribution of static random variable types, i.e. it gives</span></div>
<div class="line">      <span class="comment">// a compile time error.</span></div>
<div class="line">      extents_assert&lt;T...&gt;::assert_static();</div>
<div class="line"></div>
<div class="line">      <span class="comment">// Compile time error if T... does not match _T... (expanded type)</span></div>
<div class="line">      static_assert(util::traits::are_equivalent&lt;typename local_splitter::expanded_type, T...&gt;::value,</div>
<div class="line">          <span class="stringliteral">&quot;Random variable type mismatch&quot;</span>);</div>
<div class="line"></div>
<div class="line">      <span class="comment">// Extract the new extents from the arguments</span></div>
<div class="line">      <a class="code" href="classprob_1_1distribution.html#a0092b66fbebee633e8016f625797f05f" title="Row extents/indices tuple type.">row_type</a> new_row_extents = core::splitter&lt;_T...&gt;::row_index(std::forward&lt;_T&gt;(t)...);</div>
<div class="line">      <a class="code" href="classprob_1_1distribution.html#acd77ec1aad9829f29e9231068760b365" title="Column extents/indices tuple type.">col_type</a> new_col_extents = core::splitter&lt;_T...&gt;::col_index(std::forward&lt;_T&gt;(t)...);</div>
<div class="line"></div>
<div class="line">      <span class="comment">// Calculate the new columns and rows</span></div>
<div class="line">      <span class="keywordtype">int</span> rows = core::splitter&lt;_T...&gt;::rows(std::forward&lt;_T&gt;(t)...);</div>
<div class="line">      <span class="keywordtype">int</span> cols = core::splitter&lt;_T...&gt;::cols(std::forward&lt;_T&gt;(t)...);</div>
<div class="line"></div>
<div class="line">      <span class="comment">// Create a copy of self</span></div>
<div class="line">      <a class="code" href="classprob_1_1distribution.html#a072f64ca65f96299616a67133264a3b4" title="Default constructor.">distribution</a>&lt;Scalar, T...&gt; copy(*<span class="keyword">this</span>);</div>
<div class="line"></div>
<div class="line">      <span class="comment">// Update the distribution</span></div>
<div class="line">      _row_extents = new_row_extents;</div>
<div class="line">      _col_extents = new_col_extents;</div>
<div class="line"></div>
<div class="line">      this-&gt;resize(rows, cols);</div>
<div class="line">      this-&gt;setZero();</div>
<div class="line">      <span class="comment">// Copy the probabilities from the backup copy with the correct indices</span></div>
<div class="line">      this-&gt;<a class="code" href="classprob_1_1distribution.html#a4333addc3a829eebfe8648b01e17eca0" title="Iterate over all variable indices.">each_index</a>([<span class="keyword">this</span>, &amp;copy] (T... t) { this-&gt;prob_ref(t...) = copy.prob_read_or_zero(t...); });</div>
<div class="line">      <span class="comment">// Final normalization</span></div>
<div class="line">      this-&gt;<a class="code" href="classprob_1_1distribution.html#a0f94dd12247febf409b1406905b214fc" title="Normalize the distribution.">normalize</a>();</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classprob_1_1distribution_a4c1a6743807a2a7980fbdeb690bc8236_cgraph.png" border="0" usemap="#classprob_1_1distribution_a4c1a6743807a2a7980fbdeb690bc8236_cgraph" alt=""/></div>
<map name="classprob_1_1distribution_a4c1a6743807a2a7980fbdeb690bc8236_cgraph" id="classprob_1_1distribution_a4c1a6743807a2a7980fbdeb690bc8236_cgraph">
<area shape="rect" id="node3" href="classprob_1_1distribution.html#a4333addc3a829eebfe8648b01e17eca0" title="Iterate over all variable indices." alt="" coords="174,5,293,46"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a894a0c5da26697111aab42be99deeba1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar, typename... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classprob_1_1distribution.html">prob::distribution</a>&lt; Scalar, T &gt;::reshape_dimensions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classprob_1_1distribution.html#a0092b66fbebee633e8016f625797f05f">row_type</a> &amp;&#160;</td>
          <td class="paramname"><em>new_row_extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classprob_1_1distribution.html#acd77ec1aad9829f29e9231068760b365">col_type</a> &amp;&#160;</td>
          <td class="paramname"><em>new_col_extents</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reshape the extents of the distribution. </p>
<p>Reshapes a distribution of dynamically sized random variables and produces an runtime assertion if called with different extents on a distribution with staticly sized random variables, unless the extents are matching the static extents in which case this method does nothing.</p>
<p><b>WARNING</b> In contrast to reshape, this method does not retain the probability values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>The number of rows of the backing matrix (product of all conditional extents) </td></tr>
    <tr><td class="paramname">cols</td><td>The number of columns of the backing matrix </td></tr>
    <tr><td class="paramname">new_row_extents</td><td>The tuple of the row extents (conditional extents) </td></tr>
    <tr><td class="paramname">new_col_extents</td><td>The tuple of the column extents (posterior extents) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_distribution_8hpp_source.html#l00631">631</a> of file <a class="el" href="_distribution_8hpp_source.html">Distribution.hpp</a>.</p>
<div class="fragment"><div class="line">    {</div>
<div class="line">      <span class="keywordtype">unsigned</span> rows =</div>
<div class="line">          <a class="code" href="namespaceprob_1_1util_1_1tuple.html#a584430ef3c8c36a28fc7f78181e2d03a">util::tuple::fold</a>(</div>
<div class="line">              [] (<span class="keyword">const</span> random_event &amp;a, <span class="keywordtype">int</span> b)</div>
<div class="line">              { <span class="keywordflow">return</span> a._val*b; },</div>
<div class="line">              1,</div>
<div class="line">              new_row_extents);</div>
<div class="line"></div>
<div class="line">      <span class="keywordtype">unsigned</span> cols =</div>
<div class="line">          <a class="code" href="namespaceprob_1_1util_1_1tuple.html#a584430ef3c8c36a28fc7f78181e2d03a">util::tuple::fold</a>(</div>
<div class="line">              [] (<span class="keyword">const</span> random_event &amp;a, <span class="keywordtype">int</span> b)</div>
<div class="line">              { <span class="keywordflow">return</span> a._val*b; },</div>
<div class="line">              1,</div>
<div class="line">              new_col_extents);</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span>(extents_assert&lt;T...&gt;::is_static())</div>
<div class="line">      {</div>
<div class="line">        assert(rows == this-&gt;rows());</div>
<div class="line">        assert(cols == this-&gt;cols());</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">else</span></div>
<div class="line">      {</div>
<div class="line">        this-&gt;resize(rows, cols);</div>
<div class="line">        _row_extents = new_row_extents;</div>
<div class="line">        _col_extents = new_col_extents;</div>
<div class="line">      }</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classprob_1_1distribution_a894a0c5da26697111aab42be99deeba1_cgraph.png" border="0" usemap="#classprob_1_1distribution_a894a0c5da26697111aab42be99deeba1_cgraph" alt=""/></div>
<map name="classprob_1_1distribution_a894a0c5da26697111aab42be99deeba1_cgraph" id="classprob_1_1distribution_a894a0c5da26697111aab42be99deeba1_cgraph">
<area shape="rect" id="node3" href="namespaceprob_1_1util_1_1tuple.html#a584430ef3c8c36a28fc7f78181e2d03a" title="prob::util::tuple::fold" alt="" coords="203,12,341,39"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ae968bc8951b132e429ea5e57a7be5b6c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar, typename... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Scalar <a class="el" href="classprob_1_1distribution.html">prob::distribution</a>&lt; Scalar, T &gt;::sum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sum of all probability values in the distribution. </p>
<p>For a normalized distribution this should always return 1 and n for a normalized conditional distribution where n is the number of conditional events. </p>

<p>Definition at line <a class="el" href="_distribution_8hpp_source.html#l01069">1069</a> of file <a class="el" href="_distribution_8hpp_source.html">Distribution.hpp</a>.</p>
<div class="fragment"><div class="line">    {</div>
<div class="line">      <span class="keywordflow">return</span> matrix_type::sum();</div>
<div class="line">    };</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a7cd233e6cccabe9f3f8169e31a0d64d3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar, typename... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">conditional_distribution_type <a class="el" href="classprob_1_1distribution.html">prob::distribution</a>&lt; Scalar, T &gt;::sum_by_conditional </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sum of all probability values grouped by conditionals. </p>
<p>The result is not a proper distribution (called on a normalized conditional distribution the resulting vector should be containing only ones), however returning it as a distribution is handy for certain applications. </p>

<p>Definition at line <a class="el" href="_distribution_8hpp_source.html#l01082">1082</a> of file <a class="el" href="_distribution_8hpp_source.html">Distribution.hpp</a>.</p>
<div class="fragment"><div class="line">    {</div>
<div class="line">      <span class="keyword">auto</span> summed_matrix =  matrix_type::rowwise().sum();</div>
<div class="line">      <span class="keywordflow">return</span> conditional_distribution_type(summed_matrix.transpose(), std::make_tuple&lt;&gt;(), _row_extents);</div>
<div class="line">    };</div>
</div><!-- fragment -->
</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/harder/Dev/libprob/src/<a class="el" href="_distribution_8hpp_source.html">Distribution.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceprob.html">prob</a></li><li class="navelem"><a class="el" href="classprob_1_1distribution.html">distribution</a></li>
    <li class="footer">Generated on Tue Nov 27 2012 13:30:15 for Libprob by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.2 </li>
  </ul>
</div>
</body>
</html>
